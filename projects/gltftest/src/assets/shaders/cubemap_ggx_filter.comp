#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant, std140, row_major) uniform PushConstants {
  int mipMapLevel;
  int maxMipMapLevel;
  int numSamples;
  int dummy;
} pushConstants;

layout(set = 0, binding = 0) uniform samplerCube uSourceTexture;

layout(set = 0, binding = 1) writeonly uniform imageCube uDestinationTexture;

vec2 Hammersley(const in int index, const in int numSamples) {
  uint reversedIndex = uint(index);
  reversedIndex = (reversedIndex << 16u) | (reversedIndex >> 16u);
  reversedIndex = ((reversedIndex & 0x00ff00ffu) << 8u) | ((reversedIndex & 0xff00ff00u) >> 8u);
  reversedIndex = ((reversedIndex & 0x0f0f0f0fu) << 4u) | ((reversedIndex & 0xf0f0f0f0u) >> 4u);
  reversedIndex = ((reversedIndex & 0x33333333u) << 2u) | ((reversedIndex & 0xccccccccu) >> 2u);
  reversedIndex = ((reversedIndex & 0x55555555u) << 1u) | ((reversedIndex & 0xaaaaaaaau) >> 1u);
  return vec2(fract(float(index) / float(numSamples)), float(reversedIndex) * 2.3283064365386963e-10);
}

vec3 ImportanceSampleGGX(const in vec2 e, const in float roughness, const in vec3 normal) {
  float m = roughness * roughness;
  float m2 = m * m;
  float phi = 2.0 * 3.1415926535897932384626433832795 * e.x;
  float cosTheta = sqrt((1.0 - e.y) / (1.0 + ((m2 - 1.0) * e.y)));
  float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));
  vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
  vec3 tangentZ = normalize(normal);
  vec3 upVector = (abs(tangentZ.z) < 0.999) ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
  vec3 tangentX = normalize(cross(upVector, tangentZ));
  vec3 tangentY = cross(tangentZ, tangentX);
  return (tangentX * h.x) + (tangentY * h.y) + (tangentZ * h.z);
}

vec4 process(vec3 rayDirection) {
  float roughness = clamp(exp2((1.0 - float((pushConstants.maxMipMapLevel - 1) - pushConstants.mipMapLevel)) / 1.2), 0.0, 1.0);
  vec3 N = rayDirection;
  vec3 V = rayDirection;
  vec4 r = vec4(0.0);
  float w = 0.0;
  for (int i = 0; i < pushConstants.numSamples; i++) {
    vec3 H = ImportanceSampleGGX(Hammersley(i, pushConstants.numSamples), roughness, N);
    vec3 L = -reflect(V, H);
    float nDotL = clamp(dot(N, L), 0.0, 1.0);
    if (nDotL > 0.0) {
      r += textureLod(uSourceTexture, normalize(L), 0.0) * nDotL;
      w += nDotL;
    }
  }
  return r / max(w, 1e-4);
}

void main() {
  gl_WorkGroupSize;
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  ivec2 destinationTextureSize = imageSize(uDestinationTexture);
  vec2 p = fma((vec2(uv) + vec2(0.5)) / vec2(destinationTextureSize), vec2(2.0), vec2(-1.0));
  if (all(greaterThanEqual(uv, ivec2(0))) && all(lessThan(uv, destinationTextureSize))) {
    imageStore(uDestinationTexture, ivec3(uv, 4), process(normalize(vec3(p.x, p.y, -1))));   // front
    imageStore(uDestinationTexture, ivec3(uv, 1), process(normalize(vec3(-1, p.y, -p.x))));  // left
    imageStore(uDestinationTexture, ivec3(uv, 0), process(normalize(vec3(1, p.y, p.x))));    // right
    imageStore(uDestinationTexture, ivec3(uv, 5), process(normalize(vec3(-p.x, p.y, 1))));   // back
    imageStore(uDestinationTexture, ivec3(uv, 3), process(normalize(vec3(p.x, 1, p.y))));    // top
    imageStore(uDestinationTexture, ivec3(uv, 2), process(normalize(vec3(p.x, -1, -p.y))));  // bottom
  }
}

#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(push_constant, std140, row_major) uniform PushConstants {
  mat4 inverseProjectionMatrix;
  ivec2 tileSize; 
  vec2 zNearFar;
  vec4 viewRect;
} pushConstants;

struct AABB {
  vec4 minBounds;
  vec4 maxBounds; 
};

layout(std430, set=0, binding = 0) buffer Clusters {
  AABB clusterAABBs[];
};

/* clang-format on */

vec4 screen2Eye(vec4 coord) {
  vec3 ndc = fma(vec3((coord.xy - pushConstants.viewRect.xy) / pushConstants.viewRect.zw, coord.z), vec3(2.0), vec3(-1.0));
  vec4 eye = pushConstants.inverseProjectionMatrix * vec4(ndc, 1.0);
  return eye / eye.w;
}

void main() {
  //
  const float infinity = uintBitsToFloat(0x7f800000u);

  int clusterIndex = int((((gl_GlobalInvocationID.z * gl_WorkGroupSize.y) + gl_GlobalInvocationID.y) * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x);

  vec4 minScreen = vec3(vec2(ivec2(gl_GlobalInvocationID.xy) * pushConstants.tileSize.xy), 1.0).xyzz;
  vec4 maxScreen = vec3(vec2((ivec2(gl_GlobalInvocationID.xy) + ivec2(1)) * pushConstants.tileSize.xy), 1.0).xyzz;

  vec3 minEye = screen2Eye(minScreen).xyz;
  vec3 maxEye = screen2Eye(maxScreen).xyz;

  float clusterNear = pushConstants.zNearFar.x * pow(pushConstants.zNearFar.y / pushConstants.zNearFar.x, gl_GlobalInvocationID.z / float(gl_WorkGroupSize.z));
  float clusterFar = ((gl_GlobalInvocationID.z + 1) == gl_WorkGroupSize.z)  //
                         ? infinity                                         // the last cluster depth row is going into the infinity for a reserved z projection matrix with an actually infinite z far plane
                         : (pushConstants.zNearFar.x * pow(pushConstants.zNearFar.y / pushConstants.zNearFar.x, (gl_GlobalInvocationID.z + 1) / float(gl_WorkGroupSize.z)));

  vec3 minNear = (minEye * clusterNear) / minEye.z;
  vec3 minFar = (minEye * clusterFar) / minEye.z;
  vec3 maxNear = (maxEye * clusterNear) / maxEye.z;
  vec3 maxFar = (maxEye * clusterFar) / maxEye.z;

  clusterAABBs[clusterIndex].minBounds = vec4(vec3(min(min(minNear, minFar), min(maxNear, maxFar))), 1.0);
  clusterAABBs[clusterIndex].maxBounds = vec4(vec3(max(max(minNear, minFar), max(maxNear, maxFar))), 1.0);
}


// Platformer game application for POCA
var application = {

  data: null,

  // Game mode constants
  MODE_STARTSCREEN: 0,
  MODE_RUNNING: 1,
  MODE_GAMEOVER: 2,
  MODE_LEVELCOMPLETE: 3,

  create: function() {
    print("POCA: Platformer create\n");
    
    // Initialize game state only if not already initialized
    if (!this.data.initialized) {
      this.data.initialized = true;
      this.data.gameMode = this.MODE_STARTSCREEN;
      this.data.score = 0;
      this.data.lives = 3;
      this.data.cameraX = 0;
      this.data.cameraY = 0;
      this.data.gameWidth = 4000;
      this.data.gameHeight = 500;
      this.data.time = 0.0;
            
      // Virtual canvas size (the size we design for)
      this.data.virtualWidth = 800;
      this.data.virtualHeight = 500;
      
      // Actual canvas size (will be updated in resize)
      this.data.canvasWidth = 800;
      this.data.canvasHeight = 500;
      
      // Player properties
      this.data.player = {
        x: 100,
        y: 300,
        width: 32,
        height: 32,
        velocityX: 0,
        velocityY: 0,
        speed: 4,
        jumpPower: 15,
        isJumping: false,
        gravity: 0.5,
        maxFallSpeed: 15,
        friction: 0.5,
        facing: 'right'
      };
      
      // Key state tracking
      this.data.keys = {
        left: false,
        right: false,
        up: false,
        space: false
      };
      
      this.data.platforms = [];
      this.data.coins = [];
      this.data.enemies = [];
      this.data.goal = null;
      this.data.clouds = [];
      
      this.initGame(this.MODE_STARTSCREEN);
    }
  },

  initGame: function(gameMode) {
    print("POCA: Initializing game\n");
    
    // Reset game state
    this.data.score = 0;
    this.data.lives = 3;
    this.data.cameraX = 0;
    this.data.cameraY = 0;
    this.data.gameMode = gameMode;

    // Reset player
    this.data.player.x = 100;
    this.data.player.y = 300;
    this.data.player.velocityX = 0;
    this.data.player.velocityY = 0;
    this.data.player.isJumping = false;

    // Create clouds for parallax scrolling (appear at various depths)
    this.data.clouds = [
      // Layer 1 - Far background (scrolls at 0.2x camera speed)
      { x: 50, y: 65, scale: 0.75, layer: 0.2 },
      { x: 150, y: 45, scale: 0.75, layer: 0.2 },
      { x: 520, y: 85, scale: 0.9, layer: 0.2 },
      { x: 890, y: 35, scale: 0.8, layer: 0.2 },
      { x: 1180, y: 70, scale: 0.85, layer: 0.2 },
      { x: 1450, y: 50, scale: 0.8, layer: 0.2 },
      { x: 1820, y: 90, scale: 0.9, layer: 0.2 },
      { x: 2100, y: 40, scale: 0.75, layer: 0.2 },
      { x: 2480, y: 75, scale: 0.85, layer: 0.2 },
      { x: 2750, y: 55, scale: 0.8, layer: 0.2 },
      { x: 3050, y: 80, scale: 0.9, layer: 0.2 },
      { x: 3380, y: 45, scale: 0.85, layer: 0.2 },
      { x: 3650, y: 65, scale: 0.8, layer: 0.2 },
      { x: 3920, y: 50, scale: 0.75, layer: 0.2 },
      
      // Layer 2 - Mid background (scrolls at 0.4x camera speed)
      { x: -50, y: 115, scale: 1.0, layer: 0.4 },
      { x: 280, y: 105, scale: 1.0, layer: 0.4 },
      { x: 650, y: 130, scale: 1.15, layer: 0.4 },
      { x: 920, y: 85, scale: 1.05, layer: 0.4 },
      { x: 1250, y: 120, scale: 1.1, layer: 0.4 },
      { x: 1580, y: 95, scale: 1.0, layer: 0.4 },
      { x: 1880, y: 125, scale: 1.15, layer: 0.4 },
      { x: 2180, y: 90, scale: 1.05, layer: 0.4 },
      { x: 2520, y: 115, scale: 1.1, layer: 0.4 },
      { x: 2820, y: 100, scale: 1.0, layer: 0.4 },
      { x: 3120, y: 110, scale: 1.15, layer: 0.4 },
      { x: 3450, y: 85, scale: 1.05, layer: 0.4 },
      { x: 3750, y: 120, scale: 1.1, layer: 0.4 },
      
      // Layer 3 - Foreground (scrolls at 0.6x camera speed)
      { x: -120, y: 165, scale: 1.35, layer: 0.6 },
      { x: 380, y: 145, scale: 1.25, layer: 0.6 },
      { x: 720, y: 170, scale: 1.35, layer: 0.6 },
      { x: 1020, y: 125, scale: 1.2, layer: 0.6 },
      { x: 1350, y: 160, scale: 1.3, layer: 0.6 },
      { x: 1680, y: 135, scale: 1.25, layer: 0.6 },
      { x: 1980, y: 165, scale: 1.35, layer: 0.6 },
      { x: 2280, y: 130, scale: 1.2, layer: 0.6 },
      { x: 2620, y: 155, scale: 1.3, layer: 0.6 },
      { x: 2920, y: 140, scale: 1.25, layer: 0.6 },
      { x: 3220, y: 150, scale: 1.35, layer: 0.6 },
      { x: 3550, y: 125, scale: 1.2, layer: 0.6 },
      { x: 3850, y: 160, scale: 1.3, layer: 0.6 }
    ];

    // Create platforms
    this.data.platforms = [
      // Ground
      { x: 0, y: 450, width: 200, height: 50 },
      { x: 250, y: 450, width: 150, height: 50 },
      { x: 450, y: 450, width: 150, height: 50 },
      { x: 650, y: 450, width: 150, height: 50 },
      { x: 850, y: 450, width: 150, height: 50 },

      // Platforms
      { x: 300, y: 350, width: 100, height: 20 },
      { x: 500, y: 300, width: 100, height: 20 },
      { x: 700, y: 250, width: 100, height: 20 },
      { x: 900, y: 350, width: 100, height: 20 },
      { x: 1100, y: 300, width: 100, height: 20 },
      { x: 1300, y: 250, width: 100, height: 20 },
      { x: 1500, y: 350, width: 100, height: 20 },
      { x: 1700, y: 300, width: 100, height: 20 },
      { x: 1900, y: 250, width: 100, height: 20 },
      { x: 2100, y: 350, width: 100, height: 20 },
      { x: 2300, y: 300, width: 100, height: 20 },
      { x: 2500, y: 250, width: 100, height: 20 },
      { x: 2700, y: 350, width: 100, height: 20 },
      { x: 2900, y: 300, width: 100, height: 20 },
      { x: 3100, y: 250, width: 100, height: 20 },
      { x: 3300, y: 350, width: 100, height: 20 },
      { x: 3500, y: 300, width: 100, height: 20 },
      { x: 3700, y: 250, width: 100, height: 20 },

      // Final platform
      { x: 3900, y: 400, width: 100, height: 50 }
    ];

    // Create coins at fixed positions above platforms
    this.data.coins = [
      // Above first set of platforms
      { x: 350, y: 310, width: 16, height: 16, collected: false },
      { x: 380, y: 310, width: 16, height: 16, collected: false },
      { x: 550, y: 260, width: 16, height: 16, collected: false },
      { x: 580, y: 260, width: 16, height: 16, collected: false },
      { x: 750, y: 210, width: 16, height: 16, collected: false },
      { x: 780, y: 210, width: 16, height: 16, collected: false },
      
      // Above middle platforms
      { x: 950, y: 310, width: 16, height: 16, collected: false },
      { x: 980, y: 310, width: 16, height: 16, collected: false },
      { x: 1150, y: 260, width: 16, height: 16, collected: false },
      { x: 1180, y: 260, width: 16, height: 16, collected: false },
      { x: 1350, y: 210, width: 16, height: 16, collected: false },
      { x: 1380, y: 210, width: 16, height: 16, collected: false },
      { x: 1550, y: 310, width: 16, height: 16, collected: false },
      { x: 1580, y: 310, width: 16, height: 16, collected: false },
      { x: 1750, y: 260, width: 16, height: 16, collected: false },
      { x: 1780, y: 260, width: 16, height: 16, collected: false },
      { x: 1950, y: 210, width: 16, height: 16, collected: false },
      { x: 1980, y: 210, width: 16, height: 16, collected: false },
      
      // Above later platforms
      { x: 2150, y: 310, width: 16, height: 16, collected: false },
      { x: 2180, y: 310, width: 16, height: 16, collected: false },
      { x: 2350, y: 260, width: 16, height: 16, collected: false },
      { x: 2380, y: 260, width: 16, height: 16, collected: false },
      { x: 2550, y: 210, width: 16, height: 16, collected: false },
      { x: 2580, y: 210, width: 16, height: 16, collected: false },
      { x: 2750, y: 310, width: 16, height: 16, collected: false },
      { x: 2780, y: 310, width: 16, height: 16, collected: false },
      { x: 2950, y: 260, width: 16, height: 16, collected: false },
      { x: 2980, y: 260, width: 16, height: 16, collected: false },
      { x: 3150, y: 210, width: 16, height: 16, collected: false },
      { x: 3180, y: 210, width: 16, height: 16, collected: false },
      { x: 3350, y: 310, width: 16, height: 16, collected: false },
      { x: 3380, y: 310, width: 16, height: 16, collected: false },
      { x: 3550, y: 260, width: 16, height: 16, collected: false },
      { x: 3580, y: 260, width: 16, height: 16, collected: false },
      { x: 3750, y: 210, width: 16, height: 16, collected: false },
      { x: 3780, y: 210, width: 16, height: 16, collected: false },
      
      // Some floating coins in the air
      { x: 200, y: 250, width: 16, height: 16, collected: false },
      { x: 230, y: 250, width: 16, height: 16, collected: false },
      { x: 600, y: 150, width: 16, height: 16, collected: false },
      { x: 1000, y: 180, width: 16, height: 16, collected: false },
      { x: 1400, y: 150, width: 16, height: 16, collected: false },
      { x: 1800, y: 120, width: 16, height: 16, collected: false },
      { x: 2200, y: 150, width: 16, height: 16, collected: false },
      { x: 2600, y: 180, width: 16, height: 16, collected: false },
      { x: 3000, y: 150, width: 16, height: 16, collected: false },
      { x: 3400, y: 120, width: 16, height: 16, collected: false },
      { x: 3800, y: 150, width: 16, height: 16, collected: false }
    ];

    // Create enemies
    this.data.enemies = [
      { x: 400, y: 420, width: 32, height: 32, speed: 2, direction: 1 },
      { x: 800, y: 420, width: 32, height: 32, speed: 1.5, direction: -1 },
      { x: 1100, y: 270, width: 32, height: 32, speed: 2.5, direction: 1 },
      { x: 1500, y: 320, width: 32, height: 32, speed: 1.8, direction: -1 },
      { x: 1900, y: 220, width: 32, height: 32, speed: 2.2, direction: 1 },
      { x: 2300, y: 270, width: 32, height: 32, speed: 1.7, direction: -1 },
      { x: 2700, y: 320, width: 32, height: 32, speed: 2.3, direction: 1 },
      { x: 3100, y: 220, width: 32, height: 32, speed: 1.9, direction: -1 },
      { x: 3500, y: 270, width: 32, height: 32, speed: 2.1, direction: 1 }
    ];

    // Create goal
    this.data.goal = {
      x: 3900,
      y: 350,
      width: 32,
      height: 50
    };
  },

  destroy: function() {
    print("POCA: Application destroy\n");
  },

  show: function() {
    print("POCA: Application show\n");
  },

  hide: function() {
    print("POCA: Application hide\n");
  },

  resume: function() {
    print("POCA: Application resume\n");
  },

  pause: function() {
    print("POCA: Application pause\n");
  },

  resize: function(width, height) {
    print("POCA: Application resize to ", width, "x", height, "\n");
    this.data.canvasWidth = width;
    this.data.canvasHeight = height;
  },

  afterCreateSwapChain: function() {
    print("POCA: Application afterCreateSwapChain\n");
  },

  beforeDestroySwapChain: function() {
    print("POCA: Application beforeDestroySwapChain\n");
  },

  check: function(deltaTime) {
    // Perform checks before update
  },

  updatePlayer: function(deltaTime) {
    if(!(this.data.gameMode === this.MODE_STARTSCREEN || this.data.gameMode === this.MODE_RUNNING)) return;

    let player = this.data.player;
    
    // Horizontal movement
    if (this.data.gameMode === this.MODE_STARTSCREEN) {
      // Disable movement on start screen
      this.data.keys.left = false;
      this.data.keys.right = false;
      this.data.keys.up = false;
    }
    if (this.data.keys.left) {
      player.velocityX = -player.speed;
      player.facing = 'left';
    } else if (this.data.keys.right) {
      player.velocityX = player.speed;
      player.facing = 'right';
    } else {
      player.velocityX *= player.friction; // Friction
    }

    // Apply gravity
    player.velocityY += player.gravity;
    
    // Cap fall speed
    if (player.velocityY > player.maxFallSpeed) {
      player.velocityY = player.maxFallSpeed;
    }

    // Update position
    player.x += player.velocityX;
    player.y += player.velocityY;

    // Platform collision detection
    let onGround = false;
    for (let i = 0; i < this.data.platforms.length; i++) {
      let platform = this.data.platforms[i];
      
      if (player.x < platform.x + platform.width &&
          player.x + player.width > platform.x &&
          player.y < platform.y + platform.height &&
          player.y + player.height > platform.y) {

        // Collision from top
        if (player.velocityY > 0 && player.y < platform.y) {
          player.y = platform.y - player.height;
          player.velocityY = 0;
          player.isJumping = false;
          onGround = true;
        }
        // Collision from bottom
        else if (player.velocityY < 0 && player.y > platform.y) {
          player.y = platform.y + platform.height;
          player.velocityY = 0;
        }
        // Collision from left
        else if (player.velocityX > 0 && player.x < platform.x) {
          player.x = platform.x - player.width;
          player.velocityX = 0;
        }
        // Collision from right
        else if (player.velocityX < 0 && player.x > platform.x) {
          player.x = platform.x + platform.width;
          player.velocityX = 0;
        }
      }
    }

    // Keep player within level boundaries
    if (player.x < 0) {
      player.x = 0;
      player.velocityX = 0;
    } else if (player.x + player.width > this.data.gameWidth) {
      player.x = this.data.gameWidth - player.width;
      player.velocityX = 0;
    }

    // Update camera to follow player
    let centerX = this.data.virtualWidth / 2;
    let centerY = this.data.virtualHeight / 2;
    let safeZoneWidth = 200;
    let safeZoneHeight = 150;

    if (player.x < this.data.cameraX + centerX - safeZoneWidth) {
      this.data.cameraX = player.x - (centerX - safeZoneWidth);
    } else if (player.x > this.data.cameraX + centerX + safeZoneWidth) {
      this.data.cameraX = player.x - (centerX + safeZoneWidth);
    }

    if (player.y < this.data.cameraY + centerY - safeZoneHeight) {
      this.data.cameraY = player.y - (centerY - safeZoneHeight);
    } else if (player.y > this.data.cameraY + centerY + safeZoneHeight) {
      this.data.cameraY = player.y - (centerY + safeZoneHeight);
    }

    // Keep camera within bounds
    this.data.cameraX = Math.max(0, Math.min(this.data.cameraX, this.data.gameWidth - this.data.virtualWidth));
    this.data.cameraY = Math.max(0, Math.min(this.data.cameraY, this.data.gameHeight - this.data.virtualHeight));

    // Coin collection
    for (let i = 0; i < this.data.coins.length; i++) {
      let coin = this.data.coins[i];
      if (!coin.collected &&
          player.x < coin.x + coin.width &&
          player.x + player.width > coin.x &&
          player.y < coin.y + coin.height &&
          player.y + player.height > coin.y) {
        coin.collected = true;
        this.data.score += 100;
      }
    }

    // Enemy collision
    for (let i = this.data.enemies.length - 1; i >= 0; i--) {
      let enemy = this.data.enemies[i];
      if (player.x < enemy.x + enemy.width &&
          player.x + player.width > enemy.x &&
          player.y < enemy.y + enemy.height &&
          player.y + player.height > enemy.y) {
        
        // Check if player is jumping on enemy from above
        if (player.velocityY > 0 && player.y + player.height - player.velocityY < enemy.y + 10) {
          // Player jumped on enemy - eliminate it
          this.data.enemies.splice(i, 1);
          this.data.score += 200;
          player.velocityY = -8; // Small bounce
        } else {
          // Player hit enemy - take damage
          this.data.lives--;
          if (this.data.lives <= 0) {
            this.gameOver();
          }else{
            // Reset player position
            player.x = 100;
            player.y = 300;
            player.velocityX = 0;
            player.velocityY = 0;
          }
        }
      }
    }

    // Goal collision
    if (this.data.goal &&
        player.x < this.data.goal.x + this.data.goal.width &&
        player.x + player.width > this.data.goal.x &&
        player.y < this.data.goal.y + this.data.goal.height &&
        player.y + player.height > this.data.goal.y) {
      // Player reached goal
      this.data.score += 1000;
      this.levelComplete();
    }

    // Screen boundaries - falling off bottom
    if (player.y > this.data.gameHeight) {
      player.x = 100;
      player.y = 300;
      player.velocityX = 0;
      player.velocityY = 0;
      this.data.lives--;
      if (this.data.lives <= 0) {
        this.gameOver();
      }
    }
  },

  updateEnemies: function(deltaTime) {
    if(!(this.data.gameMode === this.MODE_STARTSCREEN || this.data.gameMode === this.MODE_RUNNING)) return;

    for (let i = 0; i < this.data.enemies.length; i++) {
      let enemy = this.data.enemies[i];
      
      // Calculate next position
      let nextX = enemy.x + enemy.speed * enemy.direction;
      
      // Check if there will be ground under the enemy
      let groundAhead = false;
      let checkX = enemy.direction > 0 ? nextX + enemy.width : nextX;
      let checkY = enemy.y + enemy.height + 5;
      
      for (let j = 0; j < this.data.platforms.length; j++) {
        let platform = this.data.platforms[j];
        if (checkX >= platform.x && 
            checkX <= platform.x + platform.width &&
            checkY >= platform.y && 
            checkY <= platform.y + platform.height) {
          groundAhead = true;
          break;
        }
      }
      
      // Check if enemy will hit a wall
      let wallAhead = false;
      for (let j = 0; j < this.data.platforms.length; j++) {
        let platform = this.data.platforms[j];
        if (nextX < platform.x + platform.width &&
            nextX + enemy.width > platform.x &&
            enemy.y < platform.y + platform.height &&
            enemy.y + enemy.height > platform.y) {
          if (Math.abs(enemy.y + enemy.height - platform.y) > 10) {
            wallAhead = true;
            break;
          }
        }
      }
      
      // Reverse direction if no ground ahead or wall ahead
      if (!groundAhead || wallAhead) {
        enemy.direction *= -1;
      } else {
        enemy.x = nextX;
      }
    }
  },

  gameOver: function() {
    this.data.gameMode = this.MODE_GAMEOVER;
    print("POCA: Game Over! Final Score: ", this.data.score, "\n");
  },

  levelComplete: function() {
    this.data.gameMode = this.MODE_LEVELCOMPLETE;
    print("POCA: Level Complete! Score: ", this.data.score, "\n");
  },

  update: function(deltaTime) {
    if (!this.data || !this.data.initialized) return;
    
    if (this.data.gameMode === this.MODE_STARTSCREEN || this.data.gameMode === this.MODE_RUNNING) {
      this.updatePlayer(deltaTime);
      this.updateEnemies(deltaTime);
    }

    this.data.time += deltaTime;

  },

  onInputEvent: function(event) {
    if (!event || !this.data || !this.data.initialized) return false;

    // Handle keyboard events
    if (event.EventType === Input.EventTypes.EVENT_KEY) {
      
      if ((event.KeyEventType === Input.KeyEventTypes.KEYEVENT_DOWN) || (event.KeyEventType === Input.KeyEventTypes.KEYEVENT_UP)) {

        let isDown = (event.KeyEventType === Input.KeyEventTypes.KEYEVENT_DOWN);
        
        if (event.KeyCode === Input.KeyCodes.KEYCODE_LEFT || event.KeyCode === Input.KeyCodes.KEYCODE_A) {
          this.data.keys.left = isDown;
          return true;
        } else if (event.KeyCode === Input.KeyCodes.KEYCODE_RIGHT || event.KeyCode === Input.KeyCodes.KEYCODE_D) {
          this.data.keys.right = isDown;
          return true;
        } else if (event.KeyCode === Input.KeyCodes.KEYCODE_UP || event.KeyCode === Input.KeyCodes.KEYCODE_W) {
          // Jump also on up, not just space
          if (this.data.gameMode === this.MODE_RUNNING && !this.data.player.isJumping) {
              this.data.player.velocityY = -this.data.player.jumpPower;
              this.data.player.isJumping = true;
          }
          this.data.keys.up = isDown;
          return true;
        } else if (event.KeyCode === Input.KeyCodes.KEYCODE_SPACE) {        
          if (isDown) {
            // Start game from start screen
            if (this.data.gameMode === this.MODE_STARTSCREEN) {
              this.initGame(this.MODE_RUNNING);
              return true;
            }
            // Restart game from game over screen
            else if (this.data.gameMode === this.MODE_GAMEOVER) {
              this.initGame(this.MODE_STARTSCREEN);
              return true;
            }
            // Continue from level complete screen
            else if (this.data.gameMode === this.MODE_LEVELCOMPLETE) {
              this.initGame(this.MODE_STARTSCREEN);
              return true;
            }
            // Jump during gameplay
            else if (this.data.gameMode === this.MODE_RUNNING && !this.data.player.isJumping) {
              this.data.player.velocityY = -this.data.player.jumpPower;
              this.data.player.isJumping = true;
            }
          }
          this.data.keys.space = isDown;
          return true;
        }

      }

    }
    
    return false;
  },

  createCanvas: function(nativeCanvas) {
    print("POCA: Application createCanvas\n");
    this.data.fontVGA = nativeCanvas.createCanvasFontFromGlobal("vga");
  },

  destroyCanvas: function(nativeCanvas) {
    this.data.fontVGA = null;
    print("POCA: Application destroyCanvas\n");
  },

  updateCanvas: function(deltaTime, width, height, nativeWidth, nativeHeight) {
    // Canvas updates handled in update()
  },

  drawCanvas: function(nativeCanvas, width, height, nativeWidth, nativeHeight) {
    if (!this.data || !this.data.initialized) {
      print("POCA: drawCanvas called but data not initialized!\n");
      return;
    }

    let canvas = nativeCanvas;
    let cameraX = this.data.cameraX;
    let cameraY = this.data.cameraY;

    // Draw background sky with gradient BEFORE view matrix (fill entire actual canvas including borders)
    // Set up linear gradient from darker blue at top to lighter blue at bottom
    canvas.setFillStyle(Canvas.FillStyle.LinearGradient);
    canvas.setStartColor(0.0625, 0.25, 0.75, 1.0);
    canvas.setStopColor(0.5, 0.75, 1.0, 1.0); 
    
    // Set fill matrix for vertical gradient (top to bottom)
    let gradientMatrix = Matrix4x4.create(
      0, 1 / width, 0, 0,
      1 / height, 0, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    );
    canvas.setFillMatrix(gradientMatrix);
    
    // Draw the gradient rectangle
    canvas.drawFilledRectangle(0, 0, width, height);
    
    // Reset to solid color fill style for other drawing
    canvas.setFillStyle(Canvas.FillStyle.Color);

    // Calculate scale to fit virtual canvas within actual canvas while preserving aspect ratio
    let scale;
    if (width / height < this.data.virtualWidth / this.data.virtualHeight) {
      scale = width / this.data.virtualWidth;
    } else {
      scale = height / this.data.virtualHeight;
    }

    // Create view matrix to scale and center the virtual canvas
    // Translate to virtual center -> Scale -> Translate to actual center
    let m1 = Matrix4x4.create(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      -this.data.virtualWidth * 0.5, -this.data.virtualHeight * 0.5, 0, 1
    );
    
    let m2 = Matrix4x4.create(
      scale, 0, 0, 0,
      0, scale, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    );
    
    let m3 = Matrix4x4.create(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      width * 0.5, height * 0.5, 0, 1
    );
    
    // Combine matrices: m1 * m2 * m3
    let viewMatrix = m1.mul(m2).mul(m3);
    canvas.setViewMatrix(viewMatrix);

    // Now draw everything in virtual canvas coordinates (not the sky background)

    // Draw sun with rotating rays
    let sunX = 400;
    let sunY = 100;
    let sunRadius = 40;
    let rayCount = 8;
    let rayRotation = this.data.time * 0.5; // Slow rotation
    
    // Draw sun rays (rotating)
    canvas.setFillStyle(Canvas.FillStyle.LinearGradient);
    canvas.setStartColor(1.0, 1.0, 0.5, 1.0);
    canvas.setStopColor(1.0, 0.75, 0.0, 0.0); 
    for (let i = 0; i < rayCount; i++) {
      let angle = (i / rayCount) * Math.PI * 2 + rayRotation;
      let rayLength = 128;
      let rayWidth = 8;
      
      // Calculate ray position
      let rayX = sunX + Math.sin(angle) * (sunRadius + rayLength / 2);
      let rayY = sunY + Math.cos(angle) * (sunRadius + rayLength / 2);
      
      // Create rotation matrix for the ray
      let cos = Math.cos(angle);
      let sin = Math.sin(angle);
      
      // Model matrix composed of three transformations:
      // 1. Translate to origin
      // 2. Rotate around origin
      // 3. Translate to final position
      let toOriginMatrix = Matrix4x4.create(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        -rayWidth / 2, -rayLength, 0, 1
      );
      
      let rotationMatrix = Matrix4x4.create(
        cos, -sin, 0, 0,
        sin, cos, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      );
      
      let translationMatrix = Matrix4x4.create(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        rayX, rayY, 0, 1
      );

      let rayMatrix = toOriginMatrix.mul(rotationMatrix).mul(translationMatrix);

      let fillMatrix = Matrix4x4.create(
        0, 1 / rayWidth, 0, 0,
        1 / rayLength, 0, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      );
      fillMatrix = rayMatrix.inverse().mul(fillMatrix);
      canvas.setFillMatrix(fillMatrix);

      canvas.setModelMatrix(rayMatrix);
      canvas.setColor(1.0, 1.0, 0.5, 1.0); // Soft yellow with transparency
      canvas.drawFilledRectangle(0, 0, rayWidth, rayLength);
    }
    
    // Reset model matrix
    let identityMatrix = Matrix4x4.create(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    );
    canvas.setModelMatrix(identityMatrix);
    
    // Reset fill style to solid color
    canvas.setFillStyle(Canvas.FillStyle.Color);

    // Draw sun core (bright yellow circle)
    canvas.setColor(1.0, 1.0, 0.5, 1.0);
    canvas.drawFilledCircle(sunX, sunY, sunRadius);
    
    // Draw sun highlight (lighter center)
    canvas.setColor(1.0, 1.0, 0.6, 1.0);
    canvas.drawFilledCircle(sunX - 8, sunY - 8, sunRadius * 0.6);

    // Draw clouds with parallax scrolling (white fluffy clouds)
    
    for (let i = 0; i < this.data.clouds.length; i++) {
      let cloud = this.data.clouds[i];

      // Calculate parallax offsets using sine and cosine for smooth movement for fluffiness motion
      let parallaxOffsetX = Math.sin(this.data.time * 0.75 + cloud.x * 0.50) * 5;
      let parallaxOffsetY = Math.cos(this.data.time * 0.50 + cloud.y * 0.75) * 2;
      let parallaxScale = 1.0 + Math.sin(this.data.time + cloud.x * 0.25) * 0.05;

      // Apply parallax effect by multiplying camera position by layer depth
      let parallaxX = cloud.x + parallaxOffsetX - (cameraX * cloud.layer);
      let parallaxY = cloud.y + parallaxOffsetY - (cameraY * cloud.layer);

      // Scale cloud size based on scale factor
      let baseSize = 30;
      let size1 = baseSize * cloud.scale * parallaxScale;
      let size2 = (baseSize * 1.125) * cloud.scale * parallaxScale;

      let backColorFactor = 0.5 + 0.125 * cloud.layer; // Lighter for farther layers
      canvas.setColor(backColorFactor, backColorFactor, backColorFactor, 0.5);       
      
      // Draw three overlapping circles to form a cloud
      let offsetX = -2.5 * cloud.scale;
      let offsetY = 2.5 * cloud.scale;
      canvas.drawFilledCircle(parallaxX + offsetX, parallaxY + offsetY, size1);
      canvas.drawFilledCircle(parallaxX + size1 + offsetX, parallaxY - 10 + offsetY, size2);
      canvas.drawFilledCircle(parallaxX + size1 * 2 + offsetX, parallaxY + offsetY, size1);

      let colorFactor = 0.75 + 0.25 * cloud.layer; // Lighter for farther layers
      canvas.setColor(colorFactor, colorFactor, colorFactor, 1.0);       
      
      // Draw three overlapping circles to form a cloud
      canvas.drawFilledCircle(parallaxX, parallaxY, size1);
      canvas.drawFilledCircle(parallaxX + size1, parallaxY - 10, size2);
      canvas.drawFilledCircle(parallaxX + size1 * 2, parallaxY, size1);
    }

    // Draw platforms
    for (let i = 0; i < this.data.platforms.length; i++) {
      let platform = this.data.platforms[i];
      
      // Brown platform
      canvas.setColor(0.55, 0.27, 0.07, 1.0);
      canvas.drawFilledRectangle(
        platform.x - cameraX,
        platform.y - cameraY,
        platform.width,
        platform.height
      );

      // Green grass top
      canvas.setColor(0.13, 0.55, 0.13, 1.0);
      canvas.drawFilledRectangle(
        platform.x - cameraX,
        platform.y - cameraY,
        platform.width,
        5
      );
    }

    // Draw coins
    for (let i = 0; i < this.data.coins.length; i++) {
      let coin = this.data.coins[i];
      if (!coin.collected) {
        // Gold coin
        canvas.setColor(1.0, 0.84, 0.0, 1.0);
        canvas.drawFilledCircle(
          coin.x + coin.width / 2 - cameraX,
          coin.y + coin.height / 2 - cameraY,
          coin.width / 2
        );
        
        // White shine
        canvas.setColor(1.0, 1.0, 1.0, 1.0);
        canvas.drawFilledCircle(
          coin.x + coin.width / 3 - cameraX,
          coin.y + coin.height / 3 - cameraY,
          coin.width / 6
        );
      }
    }

    // Draw enemies
    for (let i = 0; i < this.data.enemies.length; i++) {
      let enemy = this.data.enemies[i];
      
      // Dark red enemy body
      canvas.setColor(0.55, 0.0, 0.0, 1.0);
      canvas.drawFilledRectangle(
        enemy.x - cameraX,
        enemy.y - cameraY,
        enemy.width,
        enemy.height
      );

      // Black eyes - slightly shifted in walking direction
      let eyeOffset = enemy.direction * 2; // Shift 2 pixels in walk direction
      canvas.setColor(0.0, 0.0, 0.0, 1.0);
      canvas.drawFilledRectangle(
        enemy.x + 8 + eyeOffset - cameraX,
        enemy.y + 8 - cameraY,
        4,
        4
      );
      canvas.drawFilledRectangle(
        enemy.x + 20 + eyeOffset - cameraX,
        enemy.y + 8 - cameraY,
        4,
        4
      );
    }

    // Draw goal
    if (this.data.goal) {
      let goal = this.data.goal;
      
      // Green flag pole base
      canvas.setColor(0.0, 1.0, 0.0, 1.0);
      canvas.drawFilledRectangle(
        goal.x - cameraX,
        goal.y - cameraY,
        goal.width,
        goal.height
      );

      // White pole
      canvas.setColor(1.0, 1.0, 1.0, 1.0);
      canvas.drawFilledRectangle(
        goal.x + 10 - cameraX,
        goal.y + 5 - cameraY,
        2,
        30
      );

      // Red flag (triangle approximated with rectangle)
      canvas.setColor(1.0, 0.0, 0.0, 1.0);
      canvas.drawFilledRectangle(
        goal.x + 12 - cameraX,
        goal.y + 5 - cameraY,
        13,
        20
      );
    }

    // Draw player
    let player = this.data.player;
    canvas.setColor(1.0, 0.33, 0.33, 1.0); // Red player
    canvas.drawFilledRectangle(
      player.x - cameraX,
      player.y - cameraY,
      player.width,
      player.height
    );

    // Player eye
    canvas.setColor(0.0, 0.0, 0.0, 1.0);
    if (player.facing == 'right') {
      canvas.drawFilledRectangle(
        player.x + 20 - cameraX,
        player.y + 8 - cameraY,
        4,
        4
      );
    } else {
      canvas.drawFilledRectangle(
        player.x + 8 - cameraX,
        player.y + 8 - cameraY,
        4,
        4
      );
    }

    // Draw UI
    // Set font for text rendering
    canvas.setFont(this.data.fontVGA);
    canvas.setFontSize(24);
    
    // Draw based on game mode
    if (this.data.gameMode === this.MODE_STARTSCREEN) {
      // Start screen
      let offsetX = Math.sin(this.data.time * 2.0) * 5.0;
      let offsetY = Math.cos(this.data.time * 2.0) * 5.0;
      let offsetScale = 1.0 + (Math.sin(this.data.time * 3.0) * 0.05);
      let otherOffsetX = Math.cos((this.data.time + 0.3725) * 2.5) * 2.0; 
      let otherOffsetY = Math.sin((this.data.time + 0.3725) * 2.5) * 2.0;
      canvas.setFontSize(64 * offsetScale);
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Center);
      canvas.setColor(1.0 * 0.5, 0.5 * 0.5, 0.125 * 0.5, 1.0); // Orange text
      canvas.drawText("SUPER CUBI", this.data.virtualWidth / 2 + offsetX + otherOffsetX, this.data.virtualHeight / 2 - 100 + offsetY + otherOffsetY);
      canvas.setColor(1.0, 0.5, 0.125, 1.0); // Orange text
      canvas.drawText("SUPER CUBI", this.data.virtualWidth / 2 + offsetX, this.data.virtualHeight / 2 - 100 + offsetY);
      
      canvas.setFontSize(32);
      canvas.setColor(1.0 * 0.5, 0.84 * 0.5, 0.0 * 0.5, 1.0); // Gold text
      canvas.drawText("Adventure", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 - 40 + 2.0);
      canvas.setColor(1.0, 0.84, 0.0, 1.0); // Gold text
      canvas.drawText("Adventure", this.data.virtualWidth / 2, this.data.virtualHeight / 2 - 40);
      
      canvas.setFontSize(24);
      canvas.setColor(0.5, 0.5, 0.5, 1.0); // White text
      canvas.drawText("Arrow keys or WASD to move", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 20 + 2.0);
      canvas.drawText("Space to jump", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 50 + 2.0);
      canvas.setColor(1.0, 1.0, 1.0, 1.0); // White text
      canvas.drawText("Arrow keys or WASD to move", this.data.virtualWidth / 2, this.data.virtualHeight / 2 + 20);
      canvas.drawText("Space to jump", this.data.virtualWidth / 2, this.data.virtualHeight / 2 + 50);
      
      canvas.setFontSize(32);
      canvas.setColor(0.0, 0.5, 0.0, 1.0); // Green text
      canvas.drawText("Press SPACE to start", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 120 + 2.0);
      canvas.setColor(0.0, 1.0, 0.0, 1.0); // Green text
      canvas.drawText("Press SPACE to start", this.data.virtualWidth / 2, this.data.virtualHeight / 2 + 120);
      
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Leading); // Reset to left
      
    } else if (this.data.gameMode === this.MODE_RUNNING) {
      // Draw score during gameplay
      canvas.setColor(0.5, 0.5, 0.5, 1.0); // White text
      canvas.drawText("Score: " ~ this.data.score, 10 - 1.0, 10 + 1.0);
      canvas.setColor(1.0, 1.0, 1.0, 1.0); // White text
      canvas.drawText("Score: " ~ this.data.score, 10, 10);
      
      // Simple lives indicator - draw hearts as circles
      for (let i = 0; i < this.data.lives; i++) {
        canvas.setColor(1.0, 0.0, 0.0, 1.0);
        canvas.drawFilledCircle(20 + i * 25, 50, 8);
      }
      
    } else if (this.data.gameMode === this.MODE_GAMEOVER) {
      // Game over screen
      let offsetScale = 1.0 + (Math.sin(this.data.time * 3.0) * 0.05);
      canvas.setFontSize(64 * offsetScale);
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Center);
      canvas.setColor(0.5, 0.0, 0.0, 1.0); // Red text
      canvas.drawText("GAME OVER", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 - 60 + 2.0);
      canvas.setColor(1.0, 0.0, 0.0, 1.0); // Red text
      canvas.drawText("GAME OVER", this.data.virtualWidth / 2, this.data.virtualHeight / 2 - 60);
      
      canvas.setFontSize(32);
      canvas.setColor(0.5, 0.5, 0.5, 1.0); // White text
      canvas.drawText("Final Score: " ~ this.data.score, this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 2.0);
      canvas.setColor(1.0, 1.0, 1.0, 1.0); // White text
      canvas.drawText("Final Score: " ~ this.data.score, this.data.virtualWidth / 2, this.data.virtualHeight / 2);
      
      canvas.setFontSize(24);
      canvas.setColor(0.0, 0.5, 0.0, 1.0); // Green text
      canvas.drawText("Press SPACE to continue", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 60 + 2.0);
      canvas.setColor(0.0, 1.0, 0.0, 1.0); // Green text
      canvas.drawText("Press SPACE to continue", this.data.virtualWidth / 2, this.data.virtualHeight / 2 + 60);
      
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Leading); // Reset to left
      
    } else if (this.data.gameMode === this.MODE_LEVELCOMPLETE) {
      // Level complete screen
      let offsetScale = 1.0 + (Math.sin(this.data.time * 3.0) * 0.05);
      canvas.setFontSize(64 * offsetScale);
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Center);
      canvas.setColor(0.5, 0.42, 0.0, 1.0); // Gold shadow
      canvas.drawText("LEVEL COMPLETE!", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 - 60 + 2.0);
      canvas.setColor(1.0, 0.84, 0.0, 1.0); // Gold text
      canvas.drawText("LEVEL COMPLETE!", this.data.virtualWidth / 2, this.data.virtualHeight / 2 - 60);
      
      canvas.setFontSize(32);
      canvas.setColor(0.5, 0.5, 0.5, 1.0); // Shadow
      canvas.drawText("Final Score: " ~ this.data.score, this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 2.0);
      canvas.setColor(1.0, 1.0, 1.0, 1.0); // White text
      canvas.drawText("Final Score: " ~ this.data.score, this.data.virtualWidth / 2, this.data.virtualHeight / 2);
      
      canvas.setFontSize(24);
      canvas.setColor(0.0, 0.5, 0.0, 1.0); // Green shadow
      canvas.drawText("Press SPACE to continue", this.data.virtualWidth / 2 - 2.0, this.data.virtualHeight / 2 + 60 + 2.0);
      canvas.setColor(0.0, 1.0, 0.0, 1.0); // Green text
      canvas.drawText("Press SPACE to continue", this.data.virtualWidth / 2, this.data.virtualHeight / 2 + 60);
      
      canvas.setTextHorizontalAlignment(Canvas.TextHorizontalAlignment.Leading); // Reset to left
    }
  }

};

return application;
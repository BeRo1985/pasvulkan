#version 450
/*
 * conv_backward_data.comp â€” Compute gradient w.r.t. input (grad_input)
 *
 * Bindings: 0=weights, 1=grad_output, 2=grad_input, 3=(unused/dummy)
 * Push constants: p0=in_ch, p1=out_ch, p2=ks, p3=pad, p4=H, p5=W, p6=batch
 *
 * Copyright (C) 2026 Benjamin 'BeRo' Rosseaux. License see PasVulkan.Framework.pas (zlib)
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PC {
    int p0, p1, p2, p3, p4, p5, p6, p7;
    float f0, f1, f2, f3, f4, f5, f6, f7;
} pc;

layout(set = 0, binding = 0) readonly  buffer BufW  { float weights[];  };
layout(set = 0, binding = 1) readonly  buffer BufGO  { float grad_out[]; };
layout(set = 0, binding = 2) writeonly buffer BufGI  { float grad_in[];  };
layout(set = 0, binding = 3) readonly  buffer BufDum { float dummy[];    };

void main() {
    int iw_pos = int(gl_GlobalInvocationID.x);
    int ih_pos = int(gl_GlobalInvocationID.y);
    int nic    = int(gl_GlobalInvocationID.z);

    int in_ch  = pc.p0;
    int out_ch = pc.p1;
    int ks     = pc.p2;
    int pad    = pc.p3;
    int H      = pc.p4;
    int W      = pc.p5;
    int batch  = pc.p6;

    if (iw_pos >= W || ih_pos >= H || nic >= batch * in_ch) return;

    int n  = nic / in_ch;
    int ic = nic % in_ch;

    float sum = 0.0;
    for (int oc = 0; oc < out_ch; oc++) {
        int w_base = (oc * in_ch + ic) * ks * ks;
        int g_base = (n * out_ch + oc) * H * W;
        for (int kh = 0; kh < ks; kh++) {
            int oh = ih_pos + pad - kh;
            if (oh < 0 || oh >= H) continue;
            for (int kw = 0; kw < ks; kw++) {
                int ow_v = iw_pos + pad - kw;
                if (ow_v >= 0 && ow_v < W) {
                    sum += weights[w_base + kh * ks + kw]
                         * grad_out[g_base + oh * W + ow_v];
                }
            }
        }
    }

    grad_in[((n * in_ch + ic) * H + ih_pos) * W + iw_pos] = sum;
}

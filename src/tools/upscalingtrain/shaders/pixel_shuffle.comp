#version 450
/*
 * pixel_shuffle.comp — Rearrange (N, C·r², H, W) → (N, C, H·r, W·r)
 *
 * Bindings: 0=input, 1=output, 2=(unused), 3=(unused)
 * Push constants: p0=r, p1=out_ch (C), p4=H (LR), p5=W (LR), p6=batch
 *
 * Copyright (C) 2026 Benjamin 'BeRo' Rosseaux. License see PasVulkan.Framework.pas (zlib)
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PC {
    int p0, p1, p2, p3, p4, p5, p6, p7;
    float f0, f1, f2, f3, f4, f5, f6, f7;
} pc;

layout(set = 0, binding = 0) readonly  buffer BufI    { float inp[];    };
layout(set = 0, binding = 1) writeonly buffer BufO    { float outp[];   };
layout(set = 0, binding = 2) readonly  buffer BufDum1 { float dummy1[]; };
layout(set = 0, binding = 3) readonly  buffer BufDum2 { float dummy2[]; };

void main() {
    int ox = int(gl_GlobalInvocationID.x);  /* HR x */
    int oy = int(gl_GlobalInvocationID.y);  /* HR y */
    int nc = int(gl_GlobalInvocationID.z);  /* n * out_ch + c */

    int r      = pc.p0;
    int out_ch = pc.p1;
    int H      = pc.p4;  /* LR height */
    int W      = pc.p5;  /* LR width  */
    int batch  = pc.p6;

    int oH = H * r;
    int oW = W * r;

    if (ox >= oW || oy >= oH || nc >= batch * out_ch) return;

    int n  = nc / out_ch;
    int c  = nc % out_ch;
    int rr = r * r;

    int sy = oy % r;
    int ly = oy / r;
    int sx = ox % r;
    int lx = ox / r;

    int tch = out_ch * rr;
    int ic  = c * rr + sy * r + sx;

    outp[((n * out_ch + c) * oH + oy) * oW + ox] =
        inp[((n * tch + ic) * H + ly) * W + lx];
}

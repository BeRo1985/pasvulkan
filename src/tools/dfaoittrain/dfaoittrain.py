import numpy as np
import torch
import sys
from torch import nn
from torch import optim

# Load data
data = np.loadtxt('trainingdata.txt')
inputs = data[:, :10]
targets = data[:, 10:]

# Convert data to PyTorch tensors
inputs_tensor = torch.tensor(inputs, dtype=torch.float32)
targets_tensor = torch.tensor(targets, dtype=torch.float32)

# Define the network architecture
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(10, 32)
        self.fc2 = nn.Linear(32, 16)
        self.fc3 = nn.Linear(16, 3)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = torch.sigmoid(self.fc3(x))
        return x

# Instantiate the network
net = Net()

# Define the loss function and the optimizer
criterion = nn.MSELoss()
optimizer = optim.Adam(net.parameters(), lr=0.001)

# Training loop
for epoch in range(16384):  # Loop over the dataset multiple times
    # Zero the parameter gradients
    optimizer.zero_grad()

    # Forward + backward + optimize
    outputs = net(inputs_tensor)
    loss = criterion(outputs, targets_tensor)
    loss.backward()
    optimizer.step()

    # Print statistics
    sys.stdout.write(f'\rEpoch {epoch + 1}, Loss: {loss.item()}')
    sys.stdout.flush()

sys.stdout.write(f'\n')
sys.stdout.flush()
print('Finished Training')

# Save the trained model
torch.save(net.state_dict(), 'trained_model.pth')

# Output GLSL arrays
with open('dfaoit_network.glsl', 'w') as file:
    file.write(f'// dfaoit_network.glsl\n');
    file.write(f'// This file was automatically generated by dfaoittrain\n\n');
    for i, layer in enumerate(net.children()):
        weights = layer.weight.detach().numpy()
        biases = layer.bias.detach().numpy()

        # Generate GLSL code for declaring weights
        file.write(f'const float weights{i + 1}[{len(weights)}][{weights.shape[1]}] = {{\n')
        # iterate weights per index
        for j in range(len(weights)):
            file.write(f'  {{\n')
            weightLine = weights[j]
            for k in range(len(weightLine)):
                weight = weightLine[k]
                file.write('    ' + str(weight));
                if k != len(weightLine) - 1:
                    file.write(',')
                file.write('\n')
            file.write('  }')
            if j != len(weights) - 1:
                file.write(',')
            file.write('\n')   
        file.write('};\n\n')

        # Generate GLSL code for declaring biases
        file.write(f'const float biases{i + 1}[{len(biases)}] = {{\n')
        # iterate biases per index, one bias value per line, a bias is a number, not an array  
        for j in range(len(biases)):
            bias = biases[j] 
            file.write('  ' + str(bias));
            if j != len(biases) - 1:
                file.write(',')
            file.write('\n') 
#       file.write(str(list(biases)).replace('[', '{').replace(']', '}'))
        file.write('};\n\n')
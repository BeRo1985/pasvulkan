#version 450 core

#pragma shader_stage(compute)

// Water simulation based on "Fast Hydraulic Erosion Simulation and Visualization on GPU" by Xing Mei, Philippe Decaudin, Bao-Gang Hu
// Link: https://hal.inria.fr/inria-00402079/document

// But yet without the erosion part of the terrain part, just the water flow simulation for now.

// The paper processes evaporation and rainfall in different passes, but this shader combines both processes in the same pass,
// so it can be used in a single compute shader pass for efficiency.

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_GOOGLE_include_directive : enable

#if 0
// 16-bit floats
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#endif

/* clang-format off */

#define WORKGROUP_SIZE 16

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  uint waterHeightMapResolution; // The resolution of the water height map
  uint frameIndex; // The current frame index, used for random number generation
  float evaporation; // The evaporation constant, 0.0 means no evaporation, 1.0 means full evaporation
  float rainIntensity; // The rain intensity, 0.0 means no rain, 1.0 means full rain
  float deltaTime; // The time step in seconds
} pushConstants;

#if 0
#define _float float16_t
#define _vec4 f16vec4
#else
#define _float float
#define _vec4 vec4
#endif

layout(set = 0, binding = 0, std430) buffer WaterHeightMap {
  _float values[];
} waterHeightMap;

layout(set = 0, binding = 1) uniform sampler2D uTextureRainMap;

layout(set = 0, binding = 2) uniform sampler2D uTextureAtmosphereMap;

#include "octahedral.glsl"
#include "octahedralmap.glsl"

#include "pcg.glsl"

vec2 texelSize = 1.0 / vec2(pushConstants.waterHeightMapResolution);

uint getIndex(ivec2 position){
  const ivec2 intPosition = wrapOctahedralTexelCoordinates(ivec2(position), ivec2(pushConstants.waterHeightMapResolution));  
  return (intPosition.y * pushConstants.waterHeightMapResolution) + intPosition.x;
}


void main(){

  const uvec2 position = uvec2(gl_GlobalInvocationID.xy);

  if(all(lessThan(position, uvec2(pushConstants.waterHeightMapResolution)))){

    const uint heightMapIndex = (position.y * pushConstants.waterHeightMapResolution) + position.x;

    float waterHeight = waterHeightMap.values[heightMapIndex];

    // First evaporation
    waterHeight = max(0.0, waterHeight * (1.0 - (pushConstants.evaporation * pushConstants.deltaTime)));

    // Then rainfall
    if(pushConstants.rainIntensity > 0.0){
      vec3 positionOctahedral = octPlanetUnsignedDecode((vec2(position) + vec2(0.5)) * texelSize);
      float rainMapValue = texturePlanetOctahedralMap(uTextureRainMap, positionOctahedral).x * 
                           texturePlanetOctahedralMap(uTextureAtmosphereMap, positionOctahedral).x * // Multiply the rain intensity by the atmosphere map value as mask as well
                           pushConstants.rainIntensity *                           
                           pushConstants.deltaTime; 
      if(rainMapValue > 0.0){
        waterHeight += rainMapValue * pcgNoise(vec4(vec3(positionOctahedral) * 64.0, float(pushConstants.frameIndex) * 0.0001));    
      }
    }

    waterHeightMap.values[heightMapIndex] = waterHeight;

  }

}
// Path: src/assets/shaders/scene3d/ambientocclusion_gensamples.poca

// This script generates the sample points for the ambient occlusion shader. The sample points are generated using 
// a Halton sequence, which is a low-discrepancy sequence. The sequence is then normalized and the points are distributed
// in a sphere. The distribution of the points can be controlled by the SAMPLE_DISTRIBUTION variable. The samples are generated 
// in a hemisphere oriented along the z-axis. The generated points are then printed in the format required by the ambient
// occlusion shader.

// Implemented in my own POCA scripting language, a ECMAScript-like scripting language but with some differences.

var SAMPLE_DISTRIBUTION = 2; // 0: LINEAR (r), 1: SQUARE (r^2), 2: LINEAR SQUARE HALFWAY (r * 0.5 + r^2 * 0.5 in normalized)

function radiusFunction(r) {
  const rmin = 0.05; // minimum radius
  const rmax = 1.00; // maximum radius
  
  switch (SAMPLE_DISTRIBUTION) {
    case 0:
      // Linear: r = r;
      break;
    case 1:
      r = r * r; // Square
      break;
    case 2:
      r = r * (r + 0.5) * (2.0 / 3.0); // Linear + square halfway, normalized
      break;
    default:
      throw "error: no / invalid sample distribution chosen";
  }
  
  return rmin + ((rmax - rmin) * r);
}

function genSamples(count = 64) { // default 64 samples
  let samples = new Array(count * 4);
  for(let i = 0; i < count; i++) {
    samples[i * 4] = 0;
    samples[(i * 4) + 1] = 0;
    samples[(i * 4) + 2] = 0;
    samples[(i * 4) + 3] = 0;
  } 
  
  let radius = 1.0;
  let zShift = 0.0 * radius; // bias into the z-direction
  
  let base = [3, 7, 5]; // Halton sequence base
  let offset = [0, 0, 0]; // Halton sequence offset
  
  let cx = 0, cy = 0; // Used to calculate center point
  let i = 0, j, k = 1;
  for (i = 0; i < count; k++) {
    for (j = 0; j < 3; j++) {
      let _i = k + offset[j];
      let _f = 1.0;
      let _r = 0.0;
      while (_i > 0) {
        _f = _f / base[j];
        _r += _f * (_i % base[j]);
        _i = Math.floor(_i / base[j]);
      }
      samples[(i * 4) + j] = (_r * 2.0) - 1.0;
    }
    
    let l2 = (samples[i * 4] ** 2) + (samples[(i * 4) + 1] ** 2) + (samples[(i * 4) + 2] ** 2);
    if ((l2 > 1.0) || (samples[(i * 4) + 2] < 0)) {
      continue; // Sample invalid, discard
    } else {
      cx += samples[i * 4];
      cy += samples[(i * 4) + 1];
      i++;
    }
  }
  
  cx /= count;
  cy /= count;
  
  let l2max = 0;
  for (i = 0; i < count; i++) {
    samples[i * 4] -= cx;
    samples[(i * 4) + 1] -= cy;
    
    let l2 = (samples[i * 4] ** 2) + (samples[(i * 4) + 1] ** 2) + (samples[(i * 4) + 2] ** 2);
    if (l2 > l2max) {
      l2max = l2;
    }
  }
  
  let normlen = 1.0 / Math.sqrt(l2max);
  for (i = 0; i < count; i++) {

    let l = Math.sqrt((samples[i * 4] ** 2) + (samples[(i * 4) + 1] ** 2) + (samples[(i * 4) + 2] ** 2));

    let adjustedRadius = (radiusFunction(l) / l) * radius;
    
    samples[i * 4] *= adjustedRadius * normlen;
    samples[(i * 4) + 1] *= adjustedRadius * normlen;
    samples[(i * 4) + 2] = ((samples[(i * 4) + 2] * adjustedRadius * normlen) * (1.0 - zShift)) + zShift;
    
  }

  // Generate random radius for each sample in the W axis by shuffling the samples
  let radiusSamples = new Array(count);
  for (i = 0; i < count; i++) {
    radiusSamples[i] = (i + 1.0) / count;
  }  
  for (p = 0; p < count; p++) {
    for (i = 0; i < count; i++) {
      let v = (p << 16) | i;
      let s = ((v * 747796405) + 2891336453) & 0xffffffff;
      let w = (((s >> ((s >> 28) + 4)) ^ s) * 277803737) & 0xffffffff;
      let r = ((w >> 22) ^ w) & 0xffffffff;
      let j = r % count;
      let t = radiusSamples[i];
      radiusSamples[i] = radiusSamples[j];
      radiusSamples[j] = t;
    }
  }
  for (i = 0; i < count; i++) {
    samples[i * 4 + 3] = radiusSamples[i];
  }
  
  // Format and print the samples
  print(`const int countKernelSamples = ${count};`, "\n");
  print(`const vec4 kernelSamples[${count}] = vec4[${count}](`, "\n");
  for (i = 0; i < count; i++) {
    print(`  vec4(${samples[i * 4]}, ${samples[(i * 4) + 1]}, ${samples[(i * 4) + 2]}, ${samples[(i * 4) + 3]})${(i < count - 1) ? ',' : ''}`, "\n");
  }
  print(");\n");
}

print("// Generated by ambientocclusion_gensamples.poca\n");
print("#ifndef AMBIENTOCCLUSION_SAMPLES_GLSL\n");
print("#define AMBIENTOCCLUSION_SAMPLES_GLSL\n");
print("#if NUM_SAMPLES == 16\n");
genSamples(16);
print("#elif NUM_SAMPLES == 32\n");
genSamples(32);
print("#elif NUM_SAMPLES == 64\n");
genSamples(64);
print("#endif\n");
print("#endif\n");

#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
//#extension GL_EXT_scalar_block_layout : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (set = 0, binding = 0, std140) readonly uniform VoxelGridData {
  vec4 clipMaps[4]; // xyz = center in world-space, w = extent of a voxel 
  uint countClipMaps; // maximum 4 clipmaps
} voxelGridData;

layout (set = 0, binding = 1, std430) readonly buffer VoxelGridColors {
#if defined(USESHADERBUFFERFLOAT32ATOMICADD)
  vec4 data[]; // 32bit floating point
#else
  uvec4 data[]; // 22.12bit fixed point
#endif
} voxelGridColors;

layout (set = 0, binding = 2, std430) readonly buffer VoxelGridCounters {
  uint data[]; // 32-bit fixed point
} voxelGridCounters;

layout(set = 0, binding = 3, r32ui) writeonly uniform uimage3D uImageVolumeColor[]; // as 32-bit unsigned integer aliased/casted 9.5 bit fixed point (RGB9E5)

layout(set = 0, binding = 4, r8) writeonly uniform image3D uImageVolumeAlpha[]; // 0.0 .. 1.0 scaled 8-bit unsigned integer (R8_unorm)

layout(set = 0, binding = 5, r8) writeonly uniform image3D uImageVolumeMonoAlpha[]; // 0.0 .. 1.0 scaled 8-bit unsigned integer (R8_unorm)

#include "rgb9e5.glsl"

void main(){

  uint voxelGridSize = uint(voxelGridData.clipMaps[0].w);

  uvec3 invocation = uvec3(gl_GlobalInvocationID.xyz);

  if(all(greaterThanEqual(invocation, uvec3(0))) && all(lessThan(invocation, uvec3(uvec2(voxelGridSize), voxelGridSize * voxelGridData.countClipMaps)))){

    uint clipMapIndex = invocation.z / voxelGridSize;

    uvec3 volumePosition = uvec3(invocation.xy, invocation.z - (clipMapIndex * voxelGridSize));

    uint volumeBaseIndex = ((((((uint(clipMapIndex) * voxelGridSize) + uint(volumePosition.z)) * voxelGridSize) + uint(volumePosition.y)) * voxelGridSize) + uint(volumePosition.x)) * 6;

    vec2 volumeMonoAlpha = vec2(0.0); // x = value, y = weight 

    for(uint anisotropicAxisDirectionIndex = 0; anisotropicAxisDirectionIndex < 6; anisotropicAxisDirectionIndex++){

      uint volumeIndex = volumeBaseIndex + anisotropicAxisDirectionIndex;

      uint volumeCellCounter = voxelGridCounters.data[volumeIndex];

#if defined(USESHADERBUFFERFLOAT32ATOMICADD)
      vec4 volumeCellColor = vec4(voxelGridColors.data[volumeIndex]);
#else
      vec4 volumeCellColor = vec4(voxelGridColors.data[volumeIndex]) * (1.0 / 4096.0); // from 22.12 bit fixed point to 32-bit floating point
#endif

      vec4 volumeCellColorRGBA = volumeCellColor / max(1u, volumeCellCounter); // normalization 

      volumeMonoAlpha += vec2(voxelGridColors.data[volumeIndex].w, float(volumeCellCounter));
      
      uint volumeCellColorRGB9E5 = encodeRGB9E5(volumeCellColorRGBA.xyz); // from floating point to 9.5 bit fixed point (RGB9E5)

      uint imageIndex = (clipMapIndex * 6) + anisotropicAxisDirectionIndex;

      imageStore(uImageVolumeColor[imageIndex], ivec3(volumePosition), uvec4(volumeCellColorRGB9E5));

      imageStore(uImageVolumeAlpha[imageIndex],  ivec3(volumePosition), vec4(clamp(volumeCellColorRGBA.w, 0.0, 1.0)));

    } 

    imageStore(uImageVolumeMonoAlpha[clipMapIndex], ivec3(volumePosition), vec4(volumeMonoAlpha.x / max(1.0, volumeMonoAlpha.y)));

  }

}


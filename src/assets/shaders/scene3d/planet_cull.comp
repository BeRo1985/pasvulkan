#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive : enable

#undef TILE_SCREEN_FILL_SCALE // can occur cracks between tiles between different LOD levels
#undef PLANET_SCREEN_FILL_SCALE

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  mat4 modelMatrix;
  uint baseViewIndex;
  uint countViews;
  uint tileMapResolution;
  uint tileResolution;
  float radius;
  uint minimumLODLevel;
} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256 views as maximum for a single renderer instance (but a application/game can have multiple renderer instances for the same scene)  
} uView;

#if defined(PASS1)
layout(set = 0, binding = 1) uniform sampler2DArray uTextureDepth;
#endif

layout(set = 1, binding = 0, std430) readonly buffer BoundingBoxes {
  vec4 data[]; // pair-wise min/max, vec4 instead of vec3 for 16-byte alignment, so w is unused and zero in this case
} boundingBoxes;

layout(set = 1, binding = 1, std430) readonly buffer BoundingSpheres {
  vec4 data[]; // xyz = center, w = radius
} boundingSpheres;

layout(set = 1, binding = 2, std430) readonly buffer PreviousVisibilityBuffer {
  uint bitmap[];
} previousVisibilityBuffer;

layout(set = 1, binding = 3, std430) buffer VisibilityBuffer {
  uint bitmap[];
} visibilityBuffer;

/*
// From Vulkan spec, just as reference: 
struct VkDrawIndexedIndirectCommand {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
};
*/

struct DrawIndexedIndirectCommand {
  uvec4 cmd0; // indexCount_instanceCount_firstIndex_vertexOffset; // x = indexCount, y = instanceCount, z = firstIndex, w = vertexOffset  
  uvec4 cmd1; // firstInstance_padding0_padding1_padding2; // x = firstInstance, y = padding/unused, z = padding/unused, w = padding/unused
  vec4 boundingSphere; // xyz = center, w = radius
  uvec4 padding; // padding/unused
}; // 64 bytes per draw indexed indirect command, dividable by 32 bytes for better GPU cache line alignment 

layout(set = 1, binding = 4, std430) buffer OutputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand data[]; // 1-based, since 0 is used for counters and the like
} outputDrawIndexedIndirectCommands;

const int FrustumLeft = 0;
const int FrustumRight = 1;
const int FrustumBottom = 2;
const int FrustumTop = 3;
const int FrustumNear = 4;
const int FrustumFar = 5;

struct Frustum {
	vec4 planes[6];
  int maximumPlaneSide;
};

void frustumSetup(out Frustum frustum, mat4 m){
  // Only for 0.0 .. 1.0 depth range projection matrices
  bool reverseZ = m[2][3] < -1e-7;
  bool infiniteFarPlane = reverseZ && ((abs(m[2][2]) < 1e-7) && (abs(m[3][2]) > 1e-7));
  frustum.maximumPlaneSide = infiniteFarPlane ? FrustumNear : FrustumFar; // Avoid far plane culling for infinite far plane frustums
  mat4 t = transpose(m);
  frustum.planes[FrustumLeft] = normalize(t[3] + t[0]);
  frustum.planes[FrustumRight] = normalize(t[3] - t[0]);
  frustum.planes[FrustumBottom] = normalize(t[3] + t[1]);
  frustum.planes[FrustumTop] = normalize(t[3] - t[1]);
  if(reverseZ){
    frustum.planes[FrustumNear] = normalize(t[3] - t[2]);
    frustum.planes[FrustumFar] = normalize(/*t[3] +*/ t[2]);
  }else{
    frustum.planes[FrustumNear] = normalize(/*t[3] +*/ t[2]);
    frustum.planes[FrustumFar] = normalize(t[3] - t[2]);
  } 
}

bool frustumCullingAABBTest(const in Frustum frustum, vec3 aabbMin, vec3 aabbMax){
	for(int frustumPlaneIndex = 0; frustumPlaneIndex <= frustum.maximumPlaneSide; frustumPlaneIndex++){
    if(dot(vec4(mix(aabbMin, aabbMax, vec3(greaterThan(frustum.planes[frustumPlaneIndex].xyz, vec3(0.0)))), 1.0), frustum.planes[frustumPlaneIndex]) < 0.0){
      return false;
    }
	}
	return true;
}

void aabbTransform(inout vec3 aabbMin, inout vec3 aabbMax, mat4 m){
  if((abs(m[0][3]) + abs(m[1][3]) + abs(m[2][3]) + (abs(m[3][3]) - 1.0)) < 1e-6){
    // Fast path for affine transformations
    vec3 center = (m * vec4((aabbMin + aabbMax) * 0.5, 1.0)).xyz;
    vec3 temp = (aabbMax - aabbMin) * 0.5;
    vec3 extents = vec3(
      (abs(m[0][0]) * temp.x) + (abs(m[1][0]) * temp.y) + (abs(m[2][0]) * temp.z),
      (abs(m[0][1]) * temp.x) + (abs(m[1][1]) * temp.y) + (abs(m[2][1]) * temp.z),
      (abs(m[0][2]) * temp.x) + (abs(m[1][2]) * temp.y) + (abs(m[2][2]) * temp.z)
    );
    aabbMin = center - extents;
    aabbMax = center + extents;
  }else{
    // Slow path for non-affine transformations
    vec2 minMaxX = vec2(aabbMin.x, aabbMax.x), minMaxY = vec2(aabbMin.y, aabbMax.y), minMaxZ = vec2(aabbMin.z, aabbMax.z);
    vec4 newAABBMin = m * vec4(aabbMin, 1.0);
    newAABBMin /= newAABBMin.w;
    vec4 newAABBMax = newAABBMin;
    [[unroll]] for(int cornerIndex = 1; cornerIndex < 8; cornerIndex++){
      vec4 corner = m * vec4(minMaxX[cornerIndex & 1u], minMaxY[(cornerIndex >> 1u) & 1u], minMaxZ[(cornerIndex >> 2u) & 1u], 1.0);
      corner.xyz /= corner.w;
      newAABBMin.xyz = min(newAABBMin.xyz, corner.xyz);
      newAABBMax.xyz = max(newAABBMax.xyz, corner.xyz);
    }
    aabbMin = newAABBMin.xyz;
    aabbMax = newAABBMax.xyz;
  }
}

#include "projectsphere.glsl"

// The following variables are shared between all invocations of this shader for too keep the pre-calculations needed for the culling small, which
// are valid and the same for all invocations anyway. Other implementations uses CPU pre-calculations for it, but this is a more simple and straight 
// forward approach in my opinion, so that almost everything is done on the GPU and is in the same place, as long as it don't hurts the performance
// significantly.
shared mat4 viewMatrices[8];
shared mat4 projectionMatrices[8];
shared vec4 inverseProjectionMatrixZData[8];
shared float zNears[8]; 
shared vec4 fastFrustums[8];
shared Frustum frustums[8];

void main(){

  const uint countLODLevels = uint(log2(float(pushConstants.tileResolution)));

  uint localInvocationIndex = gl_LocalInvocationID.x;

  // Maximal 8 views at once, for example 2 for VR (for the left und right eyes), 4 for cascaded shadow maps, 6 for cube maps
  uint countViews = min(pushConstants.countViews, 8); 

  if(localInvocationIndex < countViews){
    
    uint viewIndex = pushConstants.baseViewIndex + localInvocationIndex;

    viewMatrices[localInvocationIndex] = uView.views[viewIndex].viewMatrix;

    mat4 projectionMatrix = projectionMatrices[localInvocationIndex] = uView.views[viewIndex].projectionMatrix;

    inverseProjectionMatrixZData[localInvocationIndex] = vec4(uView.views[viewIndex].inverseProjectionMatrix[2].zw, uView.views[viewIndex].inverseProjectionMatrix[3].zw);

    // Get z near from projection matrix 
    zNears[localInvocationIndex] = abs(uView.views[viewIndex].inverseProjectionMatrix[3][2] / uView.views[viewIndex].inverseProjectionMatrix[2][3]);

    mat4 transposedProjectionMatrix = transpose(uView.views[viewIndex].projectionMatrix);

    fastFrustums[localInvocationIndex] = vec4(
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[0]).xz, 
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[1]).yz
    );

    frustumSetup(frustums[localInvocationIndex], uView.views[viewIndex].projectionMatrix);
      
  }

  memoryBarrierShared();
  groupMemoryBarrier();
  barrier(); 

  const uint tileMapIndex = gl_GlobalInvocationID.x;  

  const uint tileMapSize = pushConstants.tileMapResolution * pushConstants.tileMapResolution;

  if(
     (tileMapIndex < tileMapSize)
#if defined(PASS0)
     && ((previousVisibilityBuffer.bitmap[tileMapIndex >> 5u] & (1u << (tileMapIndex & 31u))) != 0u)
#endif
    ){

#if defined(PASS1)
    vec2 viewPortSize = vec2(textureSize(uTextureDepth, 0).xy);
    int countLODLevels = textureQueryLevels(uTextureDepth);
#endif

    vec4 boundingSphere = boundingSpheres.data[tileMapIndex];
    boundingSphere.xyz = (pushConstants.modelMatrix * vec4(boundingSphere.xyz, 1.0)).xyz;

    vec3 aabbMin = boundingBoxes.data[(tileMapIndex << 1u) | 0u].xyz;
    vec3 aabbMax = boundingBoxes.data[(tileMapIndex << 1u) | 1u].xyz;

    bool visible = false;
    for(uint viewIndex = 0u; viewIndex < countViews; viewIndex++){
      vec4 viewSpaceBoundingSphere = vec4((viewMatrices[viewIndex] * vec4(boundingSphere.xyz, 1.0)).xyz, boundingSphere.w);
      vec4 fastFrustum = fastFrustums[viewIndex];
      if(//(((-viewSpaceBoundingSphere.z) + viewSpaceBoundingSphere.w) >= zNears[viewIndex]) &&
         (((viewSpaceBoundingSphere.z * fastFrustum.y) - (abs(viewSpaceBoundingSphere.x) * fastFrustum.x)) > -viewSpaceBoundingSphere.w) &&
         (((viewSpaceBoundingSphere.z * fastFrustum.w) - (abs(viewSpaceBoundingSphere.y) * fastFrustum.z)) > -viewSpaceBoundingSphere.w)){
        vec3 viewSpaceAABBMin = aabbMin;
        vec3 viewSpaceAABBMax = aabbMax;
        mat4 modelViewMatrix = viewMatrices[viewIndex] * pushConstants.modelMatrix;
        aabbTransform(viewSpaceAABBMin, viewSpaceAABBMax, modelViewMatrix);
        if(frustumCullingAABBTest(frustums[viewIndex], viewSpaceAABBMin, viewSpaceAABBMax)){

#if defined(PASS1)

          vec4 aabb;

          if(projectSphere(viewSpaceBoundingSphere.xyz, viewSpaceBoundingSphere.w, zNears[viewIndex], projectionMatrices[viewIndex], aabb)){

            vec2 size = vec2(aabb.zw - aabb.xy) * viewPortSize;

            float level = clamp(floor(log2(max(size.x, size.y))), 0.0, float(countLODLevels - 1)); 

#undef USE_FASTER_DEPTH_CALCULATIONS
#ifdef USE_FASTER_DEPTH_CALCULATIONS
            vec2 depthZ = fma(
              inverseProjectionMatrixZData[viewIndex].xy, 
              textureLod(uTextureDepth, vec3(mix(aabb.xy, aabb.zw, 0.5), float(viewIndex)), level).xx, 
              inverseProjectionMatrixZData[viewIndex].zw
            );
#else
            vec2 depthZ = (uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix * vec4(
              (aabb.xy + aabb.zw) - vec2(1.0), // optimized from: fma(mix(aabb.xy, aabb.zw, 0.5), vec2(2.0), vec2(-1.0))
              textureLod(uTextureDepth, vec3(mix(aabb.xy, aabb.zw, 0.5), float(viewIndex)), level).x, 
              1.0
            )).zw;
#endif
            float depth = -(depthZ.x / depthZ.y); // flip the sign, because z in view space is negative otherwise
            
            if(((-viewSpaceBoundingSphere.z) - viewSpaceBoundingSphere.w) <= depth){
              visible = true;
              break;
            }

          }

#elif 0          
          // Poor-man backface culling for avoiding to render the backside of the planet sphere, which is not visible anyway.
          // With ~154.2 degrees angle as threshold for backface culling for minimizing false positives.
          vec4 centerPoint = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
          centerPoint.xyz /= centerPoint.w;
          if(normalize(viewSpaceBoundingSphere.xyz - centerPoint.xyz).z >= -0.9){ 
            visible = true;
            break;
          }
#else
          visible = true;
          break;
#endif

        }
      }
    }
     
    if(visible){

      const uint outputDrawIndexedIndirectCommandIndex = atomicAdd(outputDrawIndexedIndirectCommands.data[0].cmd0.x, 1u) + 1u; // 1-based, since 0 is used for counters and the like

#if defined(PLANET_SCREEN_FILL_SCALE) || defined(TILE_SCREEN_FILL_SCALE)

#if defined(TILE_SCREEN_FILL_SCALE)
      float tileScreenFillScale = 0.0;
      for(uint viewIndex = 0u; viewIndex < countViews; viewIndex++){
        vec4 aabb2D;
        vec4 tileSphereCenter = viewMatrices[viewIndex] * vec4(boundingSphere.xyz, 1.0);
        tileSphereCenter.xyz /= tileSphereCenter.w;
        if(projectSphere(tileSphereCenter.xyz, boundingSphere.w, zNears[viewIndex], projectionMatrices[viewIndex], aabb2D)){
          tileScreenFillScale = max(tileScreenFillScale, length(aabb2D.zw - aabb2D.xy));
        }
      }
      if(tileScreenFillScale == 0.0){
        tileScreenFillScale = 1.0;
      }
#endif

#if defined(PLANET_SCREEN_FILL_SCALE)
      // Additional LOD stuff for the whole planet sphere itself
      float planetSphereScreenFillScale = 0.0;
      for(uint viewIndex = 0u; viewIndex < countViews; viewIndex++){
        vec4 planetSphereCenter = (viewMatrices[viewIndex] * pushConstants.modelMatrix) * vec4(0.0, 0.0, 0.0, 1.0);
        planetSphereCenter.xyz /= planetSphereCenter.w;
        vec4 aabb2D;
        if(projectSphere(planetSphereCenter.xyz, pushConstants.radius, zNears[viewIndex], projectionMatrices[viewIndex], aabb2D)){
          planetSphereScreenFillScale = max(planetSphereScreenFillScale, length(aabb2D.zw - aabb2D.xy) * 0.0625);
        }
      }
      if(planetSphereScreenFillScale == 0.0){
        planetSphereScreenFillScale = 1.0;
      }

#if defined(TILE_SCREEN_FILL_SCALE)
      uint lod = uint(min(max(floor(log2(1.0 / clamp(min(tileScreenFillScale, planetSphereScreenFillScale), 1e-6, 1.0))), 0.0), max(0.0, float(int(countLODLevels) - 2)))); 
#else
      uint lod = uint(min(max(floor(log2(1.0 / clamp(planetSphereScreenFillScale, 1e-6, 1.0))), 0.0), max(0.0, float(int(countLODLevels) - 2))));
#endif                                      
#else
#if defined(TILE_SCREEN_FILL_SCALE)
      uint lod = uint(min(max(floor(log2(1.0 / clamp(tileScreenFillScale, 1e-6, 1.0))), 0.0), max(0.0, float(int(countLODLevels) - 2)))); 
#else
      uint lod = 0u;
#endif      
#endif

      lod = min(max(lod, pushConstants.minimumLODLevel), max(1u, countLODLevels) - 1u);

#else
 
      const uint lod = min(pushConstants.minimumLODLevel, max(1u, countLODLevels) - 1u);

#endif // defined(PLANET_SCREEN_FILL_SCALE) || defined(TILE_SCREEN_FILL_SCALE)

      const uint tileResolution = pushConstants.tileResolution >> lod;

      const uint tileSize = tileResolution * tileResolution;

      const uint countTileIndices = tileSize * 6u;

      const uint lod0TileSize = pushConstants.tileResolution * pushConstants.tileResolution;
      uint tileIndexOffset = tileMapIndex * countTileIndices;
      for(uint lodCounter = 0u; lodCounter < lod; lodCounter++){
        tileIndexOffset += (lod0TileSize >> (lodCounter << 1u)) * (tileMapSize * 6u);
      }

      outputDrawIndexedIndirectCommands.data[outputDrawIndexedIndirectCommandIndex] = DrawIndexedIndirectCommand(
        uvec4(
          countTileIndices, // indexCount
          1u, // instanceCount
          tileIndexOffset, // firstIndex
          0u  // vertexOffset
        ),
        uvec4(
          0u, // firstInstance
          0u, // padding/unused
          0u, // padding/unused
          0u  // padding/unused
        ),
        boundingSphere,
        uvec4(0u) // padding/unused
      );

#if defined(PASS0) || defined(PASS1)
      atomicOr(visibilityBuffer.bitmap[tileMapIndex >> 5u], (1u << (tileMapIndex & 31u)));
#endif

    }
    
  }

}


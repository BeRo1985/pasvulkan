#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

/* clang-format on */

#undef MULTISCATAPPROX_ENABLED
#undef SHADOWS_ENABLED

#include "atmosphere_common.glsl"

// Push constants
layout(push_constant, std140) uniform PushConstants {
  int baseViewIndex;
  int countViews;
  int viewIndex;
  float MultipleScatteringFactor;
} pushConstants;

shared vec3 MultiScatAs1SharedMem[64];
shared vec3 LSharedMem[64];

layout(set = 0, binding = 0, rgba32f) uniform image2DArray uDestinationTexture;

layout(set = 0, binding = 1) uniform sampler2DArray uTransmittanceLutTexture;

layout(set = 0, binding = 2, std430) buffer AtmosphereParametersBuffer {
  InAtmosphereParameters inAtmosphereParameters;
} uAtmosphereParameters;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 1, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

AtmosphereParameters Atmosphere;

void main() {
  
  ivec2 xy = ivec2(gl_GlobalInvocationID.xy);

  ivec2 size = imageSize(uDestinationTexture).xy;

  int viewIndex = pushConstants.baseViewIndex + int(gl_WorkGroupID.z);

  if(any(lessThan(xy, ivec2(0))) || any(greaterThanEqual(xy, size)) && (viewIndex >= pushConstants.countViews)){
    return;
  }

  vec2 pixPos = vec2(gl_GlobalInvocationID.xy) + vec2(0.5);
  vec2 uv = pixPos / vec2(MultiScatteringLUTRes);

  uv = vec2(fromSubUvsToUnit(uv.x, MultiScatteringLUTRes), fromSubUvsToUnit(uv.y, MultiScatteringLUTRes));

  Atmosphere = getAtmosphereParameters(uAtmosphereParameters.inAtmosphereParameters);

  mat4 inverseViewMatrix = uView.views[viewIndex].inverseViewMatrix;
  mat4 inverseProjectionMatrix = uView.views[viewIndex].inverseProjectionMatrix;

  gSkyInvViewProjMat = inverseProjectionMatrix * inverseViewMatrix;

  gResolution = size;

  float cosSunZenithAngle = fma(uv.x, 2.0, 1.0);
  vec3 sunDir = vec3(0.0, sqrt(clamp(1.0 - (cosSunZenithAngle * cosSunZenithAngle), 0.0, 1.0)), cosSunZenithAngle);
  float viewHeight = Atmosphere.BottomRadius + clamp(uv.y + PLANET_RADIUS_OFFSET, 0.0, 1.0) * ((Atmosphere.TopRadius - Atmosphere.BottomRadius) - PLANET_RADIUS_OFFSET);

  vec3 WorldPos = vec3(0.0, 0.0, viewHeight);
  vec3 WorldDir = vec3(0.0, 0.0, 1.0);

  const bool ground = true;
  const float SampleCountIni = 20;
  const float DepthBufferValue = -1.0;
  const bool VariableSampleCount = false;
  const bool MieRayPhase = false;

  const float SphereSolidAngle = 4.0 * PI;
  const float IsotropicPhase = 1.0 / SphereSolidAngle;

  int localInvocationIndex = int(gl_LocalInvocationIndex) & 63;

  #define SQRTSAMPLECOUNT 8
  const float sqrtSample = float(SQRTSAMPLECOUNT);
  float i = 0.5 + float(int(gl_GlobalInvocationID.z) / SQRTSAMPLECOUNT);
  float j = 0.5 + float(int(gl_GlobalInvocationID.z) - (int(gl_GlobalInvocationID.z) / SQRTSAMPLECOUNT) * SQRTSAMPLECOUNT);
  {
    float randA = i / sqrtSample;
    float randB = j / sqrtSample;
    float theta = 2.0 * PI * randA;
    float phi = acos(1.0 - (2.0 * randB));
    vec2 cosSinPhi = vec2(sin(vec2(phi) + vec2(PI * 0.5, 0.0)));
    vec2 cosSinTheta = vec2(sin(vec2(theta) + vec2(PI * 0.5, 0.0)));
    WorldDir = vec3(cosSinTheta.xy * cosSinPhi.y, cosSinPhi.x);
    SingleScatteringResult result = IntegrateScatteredLuminance(
      uTransmittanceLutTexture,
      viewIndex,
      pixPos, 
      WorldPos, 
      WorldDir, 
      sunDir, 
      Atmosphere, 
      ground, 
      SampleCountIni, 
      DepthBufferValue, 
      VariableSampleCount, 
      MieRayPhase,
      -1.0
    );
    MultiScatAs1SharedMem[localInvocationIndex] = result.MultiScatAs1 * SphereSolidAngle / (sqrtSample * sqrtSample);
    LSharedMem[localInvocationIndex] = result.L * SphereSolidAngle / (sqrtSample * sqrtSample);
  }
  #undef SQRTSAMPLECOUNT

  barrier();
  groupMemoryBarrier();
  
  // 64 to 32
  if (localInvocationIndex < 32) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 32];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 32];
  }
  barrier();
  groupMemoryBarrier();

  // 32 to 16
  if (localInvocationIndex < 16) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 16];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 16];
  }
  barrier();
  groupMemoryBarrier();

  // 16 to 8
  if (localInvocationIndex < 8) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 8];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 8];
  }
  barrier();
  groupMemoryBarrier();

  // 8 to 4
  if (localInvocationIndex < 4) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 4];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 4];
  }
  barrier();
  groupMemoryBarrier();

  // 4 to 2
  if (localInvocationIndex < 2) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 2];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 2];
  }
  barrier();
  groupMemoryBarrier();

  // 2 to 1
  if (localInvocationIndex < 1) {
    MultiScatAs1SharedMem[localInvocationIndex] += MultiScatAs1SharedMem[localInvocationIndex + 1];
    LSharedMem[localInvocationIndex] += LSharedMem[localInvocationIndex + 1];
  }

  if (localInvocationIndex > 0) {
    return;
  }

  vec3 MultiScatAs1 = MultiScatAs1SharedMem[0] * IsotropicPhase;
  vec3 InScatteredLuminance = LSharedMem[0] * IsotropicPhase;

#if MULTI_SCATTERING_POWER_SERIE == 0
  vec3 MultiScatAs1SQR = MultiScatAs1 * MultiScatAs1;
  vec3 L = InScatteredLuminance * ((((1.0 + MultiScatAs1) + MultiScatAs1SQR) + (MultiScatAs1 * MultiScatAs1SQR)) + (MultiScatAs1SQR * MultiScatAs1SQR));
#else
  const vec3 r = MultiScatAs1;
  const vec3 SumOfAllMultiScatteringEventsContribution = 1.0 / (1.0 - r);
  vec3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;
#endif

  imageStore(uDestinationTexture, ivec3(pixPos, viewIndex), vec4(pushConstants.MultipleScatteringFactor * L, 1.0));

}
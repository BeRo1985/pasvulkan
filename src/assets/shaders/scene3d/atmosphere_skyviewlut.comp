#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* clang-format on */

#define MULTISCATAPPROX_ENABLED
#undef SHADOWS_ENABLED

#include "atmosphere_common.glsl"

// Push constants
layout(push_constant, std140) uniform PushConstants {
  int baseViewIndex;
  int countViews;
  int dummy0;
  int dummy1;
} pushConstants;  

layout(set = 0, binding = 0, rgba32f) uniform image2DArray uDestinationTexture;

layout(set = 0, binding = 1) uniform sampler2D uTransmittanceLutTexture;

layout(set = 0, binding = 2) uniform sampler2DArray uMultiScatTexture;

layout(set = 0, binding = 3, std430) buffer AtmosphereParametersBuffer {
  AtmosphereParameters atmosphereParameters;
} uAtmosphereParameters;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 1, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView; 

AtmosphereParameters atmosphereParameters;

void main() {

  ivec2 size = imageSize(uDestinationTexture).xy;

  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  int viewIndex = pushConstants.baseViewIndex + int(gl_GlobalInvocationID.z);
  
  if(all(greaterThanEqual(coord, ivec2(0))) && all(lessThan(coord, size)) && (viewIndex < pushConstants.countViews)) {

    atmosphereParameters = uAtmosphereParameters.atmosphereParameters;

    View view = uView.views[viewIndex];

    mat4 inverseViewMatrix = view.inverseViewMatrix;
    mat4 inverseProjectionMatrix = view.inverseProjectionMatrix;

    mat4 SkyInvViewProjMat = inverseProjectionMatrix * inverseViewMatrix;

    const vec2 size = vec2(192.0, 108.0);

    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(size);

    vec3 worldPos, worldDir;
    getCameraPositionDirection(worldPos, worldDir, view.viewMatrix, view.projectionMatrix, view.inverseViewMatrix, view.inverseProjectionMatrix, uv);

    worldPos = (atmosphereParameters.inverseTransform * vec4(worldPos, 1.0)).xyz;

//  worldPos += vec3(0.0, atmosphereParameters.BottomRadius, 0.0);
  
    uv = vec2(coord) / vec2(size);

    float viewHeight = max(length(worldPos), atmosphereParameters.BottomRadius + 1e-4);  

    float viewZenithCosAngle;
    float lightViewCosAngle;
    UvToSkyViewLutParams(atmosphereParameters, viewZenithCosAngle, lightViewCosAngle, viewHeight, uv);

    vec3 sunDir = vec3(0.0, 0.0, 1.0);
    {
      vec3 upVector = worldPos / viewHeight;
      float sunZenithCosAngle = dot(upVector, sunDir);
      sunDir = normalize(vec3(sqrt(1.0 - (sunZenithCosAngle * sunZenithCosAngle)), 0.0, sunZenithCosAngle));
    }

    worldPos = vec3(0.0, 0.0, viewHeight);

    float viewZenithSinAngle = sqrt(1.0 - (viewZenithCosAngle * viewZenithCosAngle));
    worldDir = vec3(viewZenithSinAngle * lightViewCosAngle, viewZenithSinAngle * sqrt(1.0 - (lightViewCosAngle * lightViewCosAngle)), viewZenithCosAngle);

    if(!MoveToTopAtmosphere(worldPos, worldDir, atmosphereParameters.TopRadius)) {
      imageStore(uDestinationTexture, ivec3(coord, viewIndex), vec4(0.0, 0.0, 0.0, 1.0));
    } else {
      const bool ground = false;
      const float sampleCountIni = 30.0;
      const float depthBufferValue = -1.0;
      const bool variableSampleCount = true;
      const bool mieRayPhase = true;
      SingleScatteringResult ss = IntegrateScatteredLuminance(
        uTransmittanceLutTexture,
        uMultiScatTexture,
        viewIndex,
        uv, 
        worldPos, 
        worldDir, 
        sunDir, 
        atmosphereParameters, 
        ground, 
        sampleCountIni, 
        depthBufferValue, 
        variableSampleCount, 
        mieRayPhase,
        SkyInvViewProjMat,
        -1.0
      ); 
      vec3 L = ss.L;
      imageStore(uDestinationTexture, ivec3(coord, viewIndex), vec4(L, 1.0));
    }

  }

}


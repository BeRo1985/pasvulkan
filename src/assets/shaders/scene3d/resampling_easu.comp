#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

// EASU - Edge-Adaptive Spatial Upsampling (FSR1 Pass 1)
//
// This is an edge-adaptive upsampling compute shader inspired by AMD's FidelityFX Super Resolution 1.0.
// It detects local edge direction and strength using luminance gradients from a 4x4 neighborhood,
// then shapes a 12-tap Lanczos2-like filter kernel as a directionally-scaled ellipse aligned to the
// detected edge. Along an edge, the filter is wide (smooth); across an edge, it is narrow (sharp).
// The result is clamped to the min/max of the 4 nearest source texels for anti-ringing.

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#ifdef MULTIVIEW
layout(set = 0, binding = 0) uniform sampler2DArray uSourceTexture;
layout(set = 0, binding = 1, rgba16f) writeonly uniform image2DArray uDestinationTexture;
#else
layout(set = 0, binding = 0) uniform sampler2D uSourceTexture;
layout(set = 0, binding = 1, rgba16f) writeonly uniform image2D uDestinationTexture;
#endif

/* clang-format on */

#include "bidirectional_tonemapping.glsl"

#ifdef MULTIVIEW
int viewIndex = int(gl_GlobalInvocationID.z);
#endif

// Lanczos2 window function approximation using two terms of the sinc expansion.
// This avoids the transcendental sin() calls by using a polynomial approximation
// of the Lanczos kernel that closely matches the true windowed sinc.
// The parameter x is the distance from the filter center in source texels.
float lanczos2Approx(float x) {
  // Attempt to approximate: (2 * sin(pi*x) * sin(pi*x/2)) / (pi^2 * x^2)
  // Using a piece-wise polynomial that is 1.0 at x=0, has correct zero crossings at x=2,
  // and is negative in the [1,2) lobe like the true Lanczos kernel.
  float x2 = x * x;
  // Piece-wise polynomial fit (accurate to within ~0.5% of the true kernel):
  // For |x| < 2: w(x) = ((25/16) * (x^2/4 - 1)^2 - (25/16 - 1)) = (25/16)(x^2/4 - 1)^2 - 9/16
  // This gives: w(0)=1, w(1)â‰ˆ0.14, w(2)=0, and has a smooth negative lobe.
  float a = (x2 * 0.25) - 1.0;
  return max(0.0, (25.0 / 16.0) * a * a - (9.0 / 16.0));
}

// Compute luminance from an RGB color.
float getLuma(vec3 c) {
  return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

// Fetch a source texel using texelFetch, clamped to source dimensions, and apply tone mapping.
vec4 fetchSource(ivec2 coord, ivec2 srcSize) {
  coord = clamp(coord, ivec2(0), srcSize - ivec2(1));
#ifdef MULTIVIEW
  return ApplyToneMapping(texelFetch(uSourceTexture, ivec3(coord, viewIndex), 0));
#else
  return ApplyToneMapping(texelFetch(uSourceTexture, coord, 0));
#endif
}

void main() {

#ifdef MULTIVIEW
  ivec3 invocationPosition = ivec3(gl_GlobalInvocationID.xyz);
  ivec3 dstSize = imageSize(uDestinationTexture);
  if (any(greaterThanEqual(invocationPosition, dstSize))) return;
#else
  ivec2 invocationPosition = ivec2(gl_GlobalInvocationID.xy);
  ivec2 dstSize = imageSize(uDestinationTexture);
  if (any(greaterThanEqual(invocationPosition, dstSize))) return;
#endif

  ivec2 dstCoord = invocationPosition.xy;
  ivec2 srcSize = ivec2(textureSize(uSourceTexture, 0).xy);

  // Compute the source-space position of this destination pixel center.
  // Map destination pixel center -> source continuous coordinates.
  vec2 srcPos = (vec2(dstCoord) + vec2(0.5)) * (vec2(srcSize) / vec2(dstSize.xy)) - vec2(0.5);

  // Integer part: the nearest source texel to the top-left.
  ivec2 srcCoord = ivec2(floor(srcPos));
  // Fractional part: sub-texel position within the source texel quad.
  vec2 f = srcPos - vec2(srcCoord);

  // ------------------------------------------------------------------
  // Gather 4x4 neighborhood of source texels and their luminances.
  // Layout (relative to srcCoord):
  //   (-1,-1) (0,-1) (1,-1) (2,-1)   <- row a
  //   (-1, 0) (0, 0) (1, 0) (2, 0)   <- row b
  //   (-1, 1) (0, 1) (1, 1) (2, 1)   <- row c
  //   (-1, 2) (0, 2) (1, 2) (2, 2)   <- row d
  // ------------------------------------------------------------------

  vec4 ca0 = fetchSource(srcCoord + ivec2(-1, -1), srcSize);
  vec4 ca1 = fetchSource(srcCoord + ivec2( 0, -1), srcSize);
  vec4 ca2 = fetchSource(srcCoord + ivec2( 1, -1), srcSize);
  vec4 ca3 = fetchSource(srcCoord + ivec2( 2, -1), srcSize);

  vec4 cb0 = fetchSource(srcCoord + ivec2(-1,  0), srcSize);
  vec4 cb1 = fetchSource(srcCoord + ivec2( 0,  0), srcSize);
  vec4 cb2 = fetchSource(srcCoord + ivec2( 1,  0), srcSize);
  vec4 cb3 = fetchSource(srcCoord + ivec2( 2,  0), srcSize);

  vec4 cc0 = fetchSource(srcCoord + ivec2(-1,  1), srcSize);
  vec4 cc1 = fetchSource(srcCoord + ivec2( 0,  1), srcSize);
  vec4 cc2 = fetchSource(srcCoord + ivec2( 1,  1), srcSize);
  vec4 cc3 = fetchSource(srcCoord + ivec2( 2,  1), srcSize);

  vec4 cd0 = fetchSource(srcCoord + ivec2(-1,  2), srcSize);
  vec4 cd1 = fetchSource(srcCoord + ivec2( 0,  2), srcSize);
  vec4 cd2 = fetchSource(srcCoord + ivec2( 1,  2), srcSize);
  vec4 cd3 = fetchSource(srcCoord + ivec2( 2,  2), srcSize);

  // Compute luminances for edge detection.
  float la0 = getLuma(ca0.rgb), la1 = getLuma(ca1.rgb), la2 = getLuma(ca2.rgb), la3 = getLuma(ca3.rgb);
  float lb0 = getLuma(cb0.rgb), lb1 = getLuma(cb1.rgb), lb2 = getLuma(cb2.rgb), lb3 = getLuma(cb3.rgb);
  float lc0 = getLuma(cc0.rgb), lc1 = getLuma(cc1.rgb), lc2 = getLuma(cc2.rgb), lc3 = getLuma(cc3.rgb);
  float ld0 = getLuma(cd0.rgb), ld1 = getLuma(cd1.rgb), ld2 = getLuma(cd2.rgb), ld3 = getLuma(cd3.rgb);

  // ------------------------------------------------------------------
  // Detect edge direction and strength using luminance gradients
  // across the four 2x2 quads that overlap the center region.
  //
  //   Quad 0 (top-left):      a1,a2,b1,b2
  //   Quad 1 (top-right):     a2,a3,b2,b3
  //   Quad 2 (bottom-left):   b1,b2,c1,c2
  //   Quad 3 (bottom-right):  b2,b3,c2,c3
  //
  // We also look at extended gradients from the outer ring for
  // more robust direction estimation.
  // ------------------------------------------------------------------

  // Horizontal and vertical gradients from each 2x2 quad.
  // Horizontal: right - left,  Vertical: bottom - top
  float dxQ0 = (la2 + lb2) - (la1 + lb1);
  float dyQ0 = (lb1 + lb2) - (la1 + la2);

  float dxQ1 = (la3 + lb3) - (la2 + lb2);
  float dyQ1 = (lb2 + lb3) - (la2 + la3);

  float dxQ2 = (lb2 + lc2) - (lb1 + lc1);
  float dyQ2 = (lc1 + lc2) - (lb1 + lb2);

  float dxQ3 = (lb3 + lc3) - (lb2 + lc2);
  float dyQ3 = (lc2 + lc3) - (lb2 + lb3);

  // Blend the four quad gradients using the sub-texel position as weights.
  // This gives a smooth gradient estimate at the output pixel position.
  float wx0 = 1.0 - f.x, wx1 = f.x;
  float wy0 = 1.0 - f.y, wy1 = f.y;

  float dx = (dxQ0 * wx0 + dxQ1 * wx1) * wy0 + (dxQ2 * wx0 + dxQ3 * wx1) * wy1;
  float dy = (dyQ0 * wx0 + dyQ1 * wx1) * wy0 + (dyQ2 * wx0 + dyQ3 * wx1) * wy1;

  // Edge direction is perpendicular to the gradient: edge = (-dy, dx).
  // Edge strength is the gradient magnitude.
  float gradLen = length(vec2(dx, dy));
  float edgeStrength = clamp(gradLen * 4.0, 0.0, 1.0); // Normalize; tweak multiplier to taste.

  // Compute edge direction angle (we only need sin and cos).
  float normFactor = 1.0 / max(gradLen, 1e-6);
  float edgeDirX = -dy * normFactor;  // Edge direction X = -gradient.y
  float edgeDirY =  dx * normFactor;  // Edge direction Y =  gradient.x

  // ------------------------------------------------------------------
  // Shape the filter kernel.
  //
  // For each of the 12 taps (the 16 texels in the 4x4 minus the 4 corners),
  // compute the distance from the destination pixel to the source texel center.
  // Then warp this distance through a directional scaling matrix:
  //
  //   Along edge direction:  stretch by (1 + edgeStrength * stretchAmount)
  //   Across edge direction: keep at 1.0 (or slightly shrink)
  //
  // This makes the filter elongate along edges, averaging more samples
  // along the edge for smoothness while staying tight across the edge
  // for sharpness.
  //
  // For simplicity and ALU savings, we use all 16 taps with the
  // directional Lanczos kernel rather than the 12-tap pattern.
  // ------------------------------------------------------------------

  // Stretch factor: how much to elongate the filter along the edge.
  // At edgeStrength=0 (flat area), stretchScale=1 (isotropic Lanczos).
  // At edgeStrength=1 (strong edge), stretchScale=2 (2x elongation along edge).
  float stretchScale = mix(1.0, 2.0, edgeStrength);

  // Build the transform matrix: rotate to edge-aligned space, scale, rotate back.
  // R = [edgeDirX, edgeDirY; -edgeDirY, edgeDirX]  (rotation to edge-aligned frame)
  // S = diag(1/stretchScale, 1)                     (compress along-edge distances)
  // M = R^T * S * R                                 (combined: shrink along-edge in original frame)
  //
  // When we shrink distances along the edge, the Lanczos kernel "sees" those texels
  // as closer, effectively widening the filter along the edge.
  float invStretch = 1.0 / stretchScale;
  // M = R^T * diag(invStretch, 1) * R
  // M[0][0] = ex*ex*is + ey*ey     M[0][1] = ex*ey*is - ex*ey = ex*ey*(is-1)
  // M[1][0] = M[0][1]              M[1][1] = ey*ey*is + ex*ex
  float mxx = edgeDirX * edgeDirX * invStretch + edgeDirY * edgeDirY;
  float mxy = edgeDirX * edgeDirY * (invStretch - 1.0);
  float myy = edgeDirY * edgeDirY * invStretch + edgeDirX * edgeDirX;

  // ------------------------------------------------------------------
  // Evaluate the directional Lanczos2 kernel for each of the 16 texels.
  // The offset of each texel relative to the sub-pixel position is
  //   d = ivec2(col, row) - f   where col in {-1,0,1,2}, row in {-1,0,1,2}
  // We transform d through M to get the effective distance, then evaluate
  // the Lanczos2 weight.
  // ------------------------------------------------------------------

  float totalWeight = 0.0;
  vec4 totalColor = vec4(0.0);

  // Anti-ringing: track min/max of the 4 nearest source texels.
  vec4 minValue = min(min(cb1, cb2), min(cc1, cc2));
  vec4 maxValue = max(max(cb1, cb2), max(cc1, cc2));

  // Macro-like inline to reduce repetition.
  // For each tap: compute distance, warp, evaluate weight, accumulate.
  #define TAP(color, offX, offY) {                                       \
    vec2 d = vec2(float(offX) - f.x, float(offY) - f.y);                 \
    /* Apply directional scaling */                                      \
    float tx = mxx * d.x + mxy * d.y;                                    \
    float ty = mxy * d.x + myy * d.y;                                    \
    float dist = sqrt(tx * tx + ty * ty);                                \
    float w = (dist < 2.0) ? lanczos2Approx(dist) : 0.0;                 \
    totalWeight += w;                                                    \
    totalColor += color * w;                                             \
  }

  // Row -1 (a)
  TAP(ca0, -1, -1)
  TAP(ca1,  0, -1)
  TAP(ca2,  1, -1)
  TAP(ca3,  2, -1)

  // Row 0 (b)
  TAP(cb0, -1,  0)
  TAP(cb1,  0,  0)
  TAP(cb2,  1,  0)
  TAP(cb3,  2,  0)

  // Row 1 (c)
  TAP(cc0, -1,  1)
  TAP(cc1,  0,  1)
  TAP(cc2,  1,  1)
  TAP(cc3,  2,  1)

  // Row 2 (d)
  TAP(cd0, -1,  2)
  TAP(cd1,  0,  2)
  TAP(cd2,  1,  2)
  TAP(cd3,  2,  2)

  #undef TAP

  // Normalize.
  vec4 result = totalColor / max(totalWeight, 1e-6);

  // Anti-ringing clamp: constrain to the bounding box of the 4 nearest source texels.
  result = clamp(result, minValue, maxValue);

  // Undo tone mapping.
  result = ApplyInverseToneMapping(result);

  // Write output.
  imageStore(uDestinationTexture, invocationPosition, result);

}

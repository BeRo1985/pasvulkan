#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  mat4 modelMatrix;
  uint baseViewIndex;
  uint countViews;
  uint tileMapResolution;
  uint tileResolution;
  float radius;
} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256 views as maximum for a single renderer instance (but a application/game can have multiple renderer instances for the same scene)  
} uView;

layout(set = 1, binding = 0, std430) readonly buffer BoundingBoxes {
  vec4 data[]; // pair-wise min/max, vec4 instead of vec3 for 16-byte alignment, so w is unused and zero in this case
} boundingBoxes;

layout(set = 1, binding = 1, std430) readonly buffer BoundingSpheres {
  vec4 data[]; // xyz = center, w = radius
} boundingSpheres;

layout(set = 1, binding = 2, std430) readonly buffer PreviousVisibilityBuffer {
  uint bitmap[];
} previousVisibilityBuffer;

layout(set = 1, binding = 3, std430) buffer VisibilityBuffer {
  uint bitmap[];
} visibilityBuffer;

/*
// From Vulkan spec, just as reference: 
struct VkDrawIndexedIndirectCommand {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
};
*/

struct DrawIndexedIndirectCommand {
  uvec4 cmd0; // indexCount_instanceCount_firstIndex_vertexOffset; // x = indexCount, y = instanceCount, z = firstIndex, w = vertexOffset  
  uvec4 cmd1; // firstInstance_padding0_padding1_padding2; // x = firstInstance, y = padding/unused, z = padding/unused, w = padding/unused
  vec4 boundingSphere; // xyz = center, w = radius
  uvec4 padding; // padding/unused
}; // 64 bytes per draw indexed indirect command, dividable by 32 bytes for better GPU cache line alignment 

layout(set = 1, binding = 4, std430) buffer OutputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand data[]; // 1-based, since 0 is used for counters and the like
} outputDrawIndexedIndirectCommands;

const int FrustumLeft = 0;
const int FrustumRight = 1;
const int FrustumBottom = 2;
const int FrustumTop = 3;
const int FrustumNear = 4;
const int FrustumFar = 5;

struct Frustum {
	vec4 planes[6];
  int maximumPlaneSide;
};

void frustumSetup(out Frustum frustum, mat4 m){
  // Only for 0.0 .. 1.0 depth range projection matrices
  bool reverseZ = m[2][3] < -1e-7;
  bool infiniteFarPlane = reverseZ && ((abs(m[2][2]) < 1e-7) && (abs(m[3][2]) > 1e-7));
  frustum.maximumPlaneSide = infiniteFarPlane ? FrustumNear : FrustumFar; // Avoid far plane culling for infinite far plane frustums
  mat4 t = transpose(m);
  frustum.planes[FrustumLeft] = normalize(t[3] + t[0]);
  frustum.planes[FrustumRight] = normalize(t[3] - t[0]);
  frustum.planes[FrustumBottom] = normalize(t[3] + t[1]);
  frustum.planes[FrustumTop] = normalize(t[3] - t[1]);
  if(reverseZ){
    frustum.planes[FrustumNear] = normalize(t[3] - t[2]);
    frustum.planes[FrustumFar] = normalize(/*t[3] +*/ t[2]);
  }else{
    frustum.planes[FrustumNear] = normalize(/*t[3] +*/ t[2]);
    frustum.planes[FrustumFar] = normalize(t[3] - t[2]);
  } 
}

bool frustumCullingAABBTest(const in Frustum frustum, vec3 aabbMin, vec3 aabbMax){
	for(int frustumPlaneIndex = 0; frustumPlaneIndex <= frustum.maximumPlaneSide; frustumPlaneIndex++){
    if(dot(vec4(mix(aabbMin, aabbMax, vec3(greaterThan(frustum.planes[frustumPlaneIndex].xyz, vec3(0.0)))), 1.0), frustum.planes[frustumPlaneIndex]) < 0.0){
      return false;
    }
	}
	return true;
}

void aabbTransform(inout vec3 aabbMin, inout vec3 aabbMax, mat4 m){
  if((abs(m[0][3]) + abs(m[1][3]) + abs(m[2][3]) + (abs(m[3][3]) - 1.0)) < 1e-6){
    // Fast path for affine transformations
    vec3 center = (m * vec4((aabbMin + aabbMax) * 0.5, 1.0)).xyz;
    vec3 temp = (aabbMax - aabbMin) * 0.5;
    vec3 extents = vec3(
      (abs(m[0][0]) * temp.x) + (abs(m[1][0]) * temp.y) + (abs(m[2][0]) * temp.z),
      (abs(m[0][1]) * temp.x) + (abs(m[1][1]) * temp.y) + (abs(m[2][1]) * temp.z),
      (abs(m[0][2]) * temp.x) + (abs(m[1][2]) * temp.y) + (abs(m[2][2]) * temp.z)
    );
    aabbMin = center - extents;
    aabbMax = center + extents;
  }else{
    // Slow path for non-affine transformations
    vec2 minMaxX = vec2(aabbMin.x, aabbMax.x), minMaxY = vec2(aabbMin.y, aabbMax.y), minMaxZ = vec2(aabbMin.z, aabbMax.z);
    vec4 newAABBMin = m * vec4(aabbMin, 1.0);
    newAABBMin /= newAABBMin.w;
    vec4 newAABBMax = newAABBMin;
    [[unroll]] for(int cornerIndex = 1; cornerIndex < 8; cornerIndex++){
      vec4 corner = m * vec4(minMaxX[cornerIndex & 1u], minMaxY[(cornerIndex >> 1u) & 1u], minMaxZ[(cornerIndex >> 2u) & 1u], 1.0);
      corner.xyz /= corner.w;
      newAABBMin.xyz = min(newAABBMin.xyz, corner.xyz);
      newAABBMax.xyz = max(newAABBMax.xyz, corner.xyz);
    }
    aabbMin = newAABBMin.xyz;
    aabbMax = newAABBMax.xyz;
  }
}

bool projectSphere(const in vec3 center, const in float radius, const in float zNear, const in mat4 projectionMatrix, out vec4 aabb){

  if(((-center.z) - radius) < zNear){

    return false;

  }else{

    vec3 right = (projectionMatrix * vec4(vec3(-center.z, 0.0, center.x) * (radius / sqrt(dot(center, center) - (radius * radius))), 0.0)).xyw;
    vec3 up = (projectionMatrix * vec2(0.0, radius).xyxx).xyw;

    vec3 anchorCenter = (projectionMatrix * vec4(center, 1.0)).xyw;

    vec2 leftAnchor = (anchorCenter.xy - right.xy) / (anchorCenter.z - right.z);
    vec2 rightAnchor = (anchorCenter.xy + right.xy) / (anchorCenter.z + right.z);
    vec2 downAnchor = (anchorCenter.xy - up.xy) / (anchorCenter.z - up.z);
    vec2 upAnchor = (anchorCenter.xy + up.xy) / (anchorCenter.z + up.z);

    aabb = fma(
      vec4(
        min(min(min(leftAnchor, rightAnchor), downAnchor), upAnchor),
        max(max(max(leftAnchor, rightAnchor), downAnchor), upAnchor)
      ),
      vec4(0.5),
      vec4(0.5)
    );

    return true;

  }

}

// The following variables are shared between all invocations of this shader for too keep the pre-calculations needed for the culling small, which
// are valid and the same for all invocations anyway. Other implementations uses CPU pre-calculations for it, but this is a more simple and straight 
// forward approach in my opinion, so that almost everything is done on the GPU and is in the same place, as long as it don't hurts the performance
// significantly.
shared mat4 viewMatrices[8];
shared mat4 projectionMatrices[8];
shared vec4 inverseProjectionMatrixZData[8];
shared float zNears[8]; 
shared vec4 fastFrustums[8];
shared Frustum frustums[8];

void main(){

  const uint countLODLevels = uint(log2(float(pushConstants.tileResolution)));

  uint localInvocationIndex = gl_LocalInvocationID.x;

  // Maximal 8 views at once, for example 2 for VR (for the left und right eyes), 4 for cascaded shadow maps, 6 for cube maps
  uint countViews = min(pushConstants.countViews, 8); 

  if(localInvocationIndex < countViews){
    
    uint viewIndex = pushConstants.baseViewIndex + localInvocationIndex;

    viewMatrices[localInvocationIndex] = uView.views[viewIndex].viewMatrix;

    mat4 projectionMatrix = projectionMatrices[localInvocationIndex] = uView.views[viewIndex].projectionMatrix;

    inverseProjectionMatrixZData[localInvocationIndex] = vec4(uView.views[viewIndex].inverseProjectionMatrix[2].zw, uView.views[viewIndex].inverseProjectionMatrix[3].zw);

    // Get z near from projection matrix 
    zNears[localInvocationIndex] = abs(uView.views[viewIndex].inverseProjectionMatrix[3][2] / uView.views[viewIndex].inverseProjectionMatrix[2][3]);

    mat4 transposedProjectionMatrix = transpose(uView.views[viewIndex].projectionMatrix);

    fastFrustums[localInvocationIndex] = vec4(
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[0]).xz, 
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[1]).yz
    );

    frustumSetup(frustums[localInvocationIndex], uView.views[viewIndex].projectionMatrix);
      
  }

  memoryBarrierShared();
  groupMemoryBarrier();
  barrier(); 

  const uint tileMapIndex = gl_GlobalInvocationID.x;  

  const uint tileMapSize = pushConstants.tileMapResolution * pushConstants.tileMapResolution;

  if(tileMapIndex < tileMapSize){

    vec4 boundingSphere = boundingSpheres.data[tileMapIndex];
    boundingSphere.xyz = (pushConstants.modelMatrix * vec4(boundingSphere.xyz, 1.0)).xyz;

    vec3 aabbMin = boundingBoxes.data[(tileMapIndex << 1u) | 0u].xyz;
    vec3 aabbMax = boundingBoxes.data[(tileMapIndex << 1u) | 1u].xyz;

    bool visible = false;
    for(uint viewIndex = 0u; viewIndex < countViews; viewIndex++){
      vec4 viewSpaceBoundingSphere = vec4((viewMatrices[viewIndex] * vec4(boundingSphere.xyz, 1.0)).xyz, boundingSphere.w);
      vec4 fastFrustum = fastFrustums[viewIndex];
      if(//(((-viewSpaceBoundingSphere.z) + viewSpaceBoundingSphere.w) >= zNears[viewIndex]) &&
         (((viewSpaceBoundingSphere.z * fastFrustum.y) - (abs(viewSpaceBoundingSphere.x) * fastFrustum.x)) > -viewSpaceBoundingSphere.w) &&
         (((viewSpaceBoundingSphere.z * fastFrustum.w) - (abs(viewSpaceBoundingSphere.y) * fastFrustum.z)) > -viewSpaceBoundingSphere.w)){
        vec3 viewSpaceAABBMin = aabbMin;
        vec3 viewSpaceAABBMax = aabbMax;
        mat4 modelViewMatrix = viewMatrices[viewIndex] * pushConstants.modelMatrix;
        aabbTransform(viewSpaceAABBMin, viewSpaceAABBMax, modelViewMatrix);
        if(frustumCullingAABBTest(frustums[viewIndex], viewSpaceAABBMin, viewSpaceAABBMax)){
          
          // Poor-man backface culling for avoiding to render the backside of the planet sphere, which is not visible anyway.
          // With ~154.2 degrees angle as threshold for backface culling for minimizing false positives.
          vec4 centerPoint = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
          centerPoint.xyz /= centerPoint.w;
          if(normalize(viewSpaceBoundingSphere.xyz - centerPoint.xyz).z >= -0.9){ 
            visible = true;
            break;
          }

        }
      }
    }
      
    if(visible){

      vec2 aabb2DMin, aabb2DMax;
      {
        mat4 modelViewProjectionMatrix = projectionMatrices[0] * viewMatrices[0] * pushConstants.modelMatrix;
        for(uint cornerIndex = 0u; cornerIndex < 8u; cornerIndex++){
          vec4 corner = modelViewProjectionMatrix * vec4(mix(aabbMin, aabbMax, vec3(greaterThanEqual(uvec3(cornerIndex & 1u, (cornerIndex >> 1u) & 1u, (cornerIndex >> 2u) & 1u), uvec3(1u)))), 1.0);
          corner.xy = fma(corner.xy / corner.w, vec2(0.5), vec2(0.5)); // Perspective divide and transform to 0.0 .. 1.0 range
          if(cornerIndex == 0u){
            aabb2DMin = aabb2DMax = corner.xy;
          }else{
            aabb2DMin = min(aabb2DMin, corner.xy);
            aabb2DMax = max(aabb2DMax, corner.xy);
          }
        }
      }
      
      // Safe-check if the 2D projected AABB is visible at all, just for to be sure
      if(!(all(greaterThan(aabb2DMin, vec2(1.0))) || all(lessThan(aabb2DMax, vec2(0.0))))){

        float screenFillScale = length(aabb2DMax - aabb2DMin);

        const uint outputDrawIndexedIndirectCommandIndex = atomicAdd(outputDrawIndexedIndirectCommands.data[0].cmd0.x, 1u) + 1u; // 1-based, since 0 is used for counters and the like

        {
          vec4 aabb2D;
          vec4 planetSphereCenter = pushConstants.modelMatrix * vec4(0.0, 0.0, 0.0, 1.0);
          planetSphereCenter.xyz /= planetSphereCenter.w;
          if(projectSphere(planetSphereCenter.xyz, pushConstants.radius, zNears[0], projectionMatrices[0], aabb2D)) {
            screenFillScale = min(screenFillScale, pow(length(aabb2D.zw - aabb2D.xy), 2.0));
          }
        }

        const uint lod = uint(min(max(round(log2(1.0 / clamp(screenFillScale, 1e-6, 1.0))), 0.0), float(countLODLevels - 1u))); 

        const uint tileResolution = pushConstants.tileResolution >> lod;

        const uint tileSize = tileResolution * tileResolution;

        const uint countTileIndices = tileSize * 6u;

        const uint lod0TileSize = pushConstants.tileResolution * pushConstants.tileResolution;
        uint tileIndexOffset = tileMapIndex * countTileIndices;
        for(uint lodCounter = 0u; lodCounter < lod; lodCounter++){
          tileIndexOffset += (lod0TileSize >> (lodCounter << 1u)) * (tileMapSize * 6u);
        }

        outputDrawIndexedIndirectCommands.data[outputDrawIndexedIndirectCommandIndex] = DrawIndexedIndirectCommand(
          uvec4(
            countTileIndices, // indexCount
            1u, // instanceCount
            tileIndexOffset, // firstIndex
            0u  // vertexOffset
          ),
          uvec4(
            0u, // firstInstance
            0u, // padding/unused
            0u, // padding/unused
            0u  // padding/unused
          ),
          boundingSphere,
          uvec4(0u) // padding/unused
        );

      }

    }
    
  }

}


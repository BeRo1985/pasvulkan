#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  uint indexOffset;
  uint countIndices;
} pushConstants;

struct InPackedVertex {
  uvec4 positionMorphTargetVertexBaseIndex; // xyz = position, w = morphTargetVertexBaseIndex
  uvec4 jointBlockBaseIndexCountJointBlocksRootNodeNodeIndex; // x = jointBlockBaseIndex, y = countJointBlocks, z = rootNode, w = nodeIndex
  uvec4 normalTangentFlagsGeneration; // x = normal (2x half oct), y = tangent (2x half oct), z = flags, w = generation
};

struct OutPackedVertex {
  uvec4 positionNormalXY; // xyz = position (32-bit float), w = normal x y (16-bit signed normalized)
  uvec4 normalZSignTangentXYZModelScaleXYZ; // x = normal z + sign of tangent z (16-bit signed normalized), y = tangent x y (16-bit signed normalized), z = tangent z + model scale x (16-bit float), w = model scale y z (16-bit float)
};

#ifdef RAYTRACING
struct OutRayTracingVertex {
  uvec4 position; // w=unused
};
#endif

struct MorphTargetVertex {
   vec4 position;
   vec4 normal;
   vec4 tangent;
   uvec4 metaData; // x = index, y = next
};

// Static descriptor set

layout(set = 0, binding = 0, std430) buffer InVertices {
  InPackedVertex inVertices[];
};

layout(set = 0, binding = 1, std430) buffer InIndices {
  uint inIndices[];
};

layout(set = 0, binding = 2, std430) buffer MorphTargetVertices {
  MorphTargetVertex morphTargetVertices[];
};

struct JointBlock {
  uvec4 joints;
  vec4 weights;
};

layout(set = 0, binding = 3, std430) buffer JointBlocks {
  JointBlock jointBlocks[];
};

// Dynamic descriptor set

layout(set = 1, binding = 0, std430) buffer OutVertices {
  OutPackedVertex outVertices[];
};

layout(set = 1, binding = 1, std430) buffer OutGenerations {
  uint outGenerations[];
};

layout(set = 1, binding = 2, std430) buffer NodeMatrices {
  mat4 nodeMatrices[];
};

layout(set = 1, binding = 3, std430) buffer MorphTargetWeights {
  float morphTargetWeights[];
};

#ifdef RAYTRACING
layout(set = 1, binding = 4, std430) buffer OutRayTracingVertices {
  OutRayTracingVertex outRayTracingVertices[];
};
#endif

/* clang-format on */

vec3 octDecode(vec2 oct) {
  vec3 v = vec3(oct.xy, 1.0 - (abs(oct.x) + abs(oct.y)));
  if (v.z < 0.0) {
    v.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? 1.0 : -1.0, (v.y >= 0.0) ? 1.0 : -1.0);
  }
  return normalize(v);
}

void main() {
  uint vertexIndex = gl_GlobalInvocationID.x;
  // uint vertexIndex = uint((((gl_GlobalInvocationID.z * gl_WorkGroupSize.y) + gl_GlobalInvocationID.y) * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x);
  if (vertexIndex < pushConstants.countIndices) {

    vertexIndex = inIndices[vertexIndex + pushConstants.indexOffset];

    {

      InPackedVertex inPackedVertex = inVertices[vertexIndex];
      const vec3 inPosition = uintBitsToFloat(inPackedVertex.positionMorphTargetVertexBaseIndex.xyz);
      const uint inMorphTargetVertexBaseIndex = inPackedVertex.positionMorphTargetVertexBaseIndex.w;
      const uint inJointBlockBaseIndex = inPackedVertex.jointBlockBaseIndexCountJointBlocksRootNodeNodeIndex.x;
      const uint inCountJointBlocks = inPackedVertex.jointBlockBaseIndexCountJointBlocksRootNodeNodeIndex.y;
      const uint inRootNode = inPackedVertex.jointBlockBaseIndexCountJointBlocksRootNodeNodeIndex.z;
      const uint inNodeIndex = inPackedVertex.jointBlockBaseIndexCountJointBlocksRootNodeNodeIndex.w;
      const vec2 inNormal = unpackSnorm2x16(inPackedVertex.normalTangentFlagsGeneration.x);
      const vec2 inTangent = unpackSnorm2x16(inPackedVertex.normalTangentFlagsGeneration.y);
      const uint inFlags = inPackedVertex.normalTangentFlagsGeneration.z;
      const uint inGeneration = inPackedVertex.normalTangentFlagsGeneration.w;

      mat4 nodeMatrix = nodeMatrices[inNodeIndex];

      mat4 modelNodeMatrix = nodeMatrices[inRootNode] * nodeMatrix;
	  
      vec3 position = inPosition;

      mat3 tangentSpace;
      {
        vec3 tangent = octDecode(inTangent);
        vec3 normal = octDecode(inNormal);
        tangentSpace = mat3(tangent, normalize(cross(normal, tangent)) * (((inFlags & (1u << 0)) != 0) ? -1.0 : 1.0), normal);
      }
      // mat3 tangentSpace = mat3(inTangent.xyz, cross(inTangent.xyz, inNormal) * inTangent.w, inNormal);

      if (inMorphTargetVertexBaseIndex != 0xffffffffu) {
        vec4 normal = vec4(tangentSpace[2], 0.0f);
        vec4 tangent = vec4(tangentSpace[0], sign(dot(cross(tangentSpace[2], tangentSpace[0]), tangentSpace[1])));
        uint morphTargetVertexIndex = inMorphTargetVertexBaseIndex;
        uint protectionCounter = 0x0ffffu;
        while ((morphTargetVertexIndex != 0xffffffffu) && (protectionCounter-- > 0u)) {
          MorphTargetVertex morphTargetVertex = morphTargetVertices[morphTargetVertexIndex];
          float weight = morphTargetWeights[morphTargetVertex.metaData.x];
          position += morphTargetVertex.position.xyz * weight;
          normal += vec4(morphTargetVertex.normal.xyz, 1.0) * weight;
          tangent.xyz += morphTargetVertex.tangent.xyz * weight;
          morphTargetVertexIndex = morphTargetVertex.metaData.y;
        }
        normal.xyz = normalize(normal.xyz);
        tangent.xyz = normalize(tangent.xyz);
        tangentSpace = mat3(tangent.xyz, normalize(cross(normal.xyz, tangent.xyz) * tangent.w), normal.xyz);
      }

      if (inCountJointBlocks > 0u) {
        mat4 inverseNodeMatrix = inverse(nodeMatrix);
        mat4 skinMatrix = mat4(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
        for (uint jointBlockBaseIndex = inJointBlockBaseIndex, endJointBlockBaseIndex = jointBlockBaseIndex + inCountJointBlocks;  //
             jointBlockBaseIndex < endJointBlockBaseIndex;                                                                         //
             jointBlockBaseIndex++) {
          JointBlock jointBlock = jointBlocks[jointBlockBaseIndex];
          skinMatrix += ((inverseNodeMatrix * nodeMatrices[jointBlock.joints.x]) * jointBlock.weights.x) +  //
                        ((inverseNodeMatrix * nodeMatrices[jointBlock.joints.y]) * jointBlock.weights.y) +  //
                        ((inverseNodeMatrix * nodeMatrices[jointBlock.joints.z]) * jointBlock.weights.z) +  //
                        ((inverseNodeMatrix * nodeMatrices[jointBlock.joints.w]) * jointBlock.weights.w);
        }
#ifdef RAYTRACING
        nodeMatrix *= skinMatrix;
#endif
        modelNodeMatrix *= skinMatrix;
      }

      mat3 normalMatrix = transpose(inverse(mat3(modelNodeMatrix)));

      tangentSpace = normalMatrix * tangentSpace;

      vec4 p = modelNodeMatrix * vec4(position.xyz, 1.0);
      position = p.xyz / p.w;

      {
	  
        vec3 tangent = normalize(tangentSpace[0]);
        vec3 bitangent = normalize(tangentSpace[1]);
        vec3 normal = normalize(tangentSpace[2]);

        float tbnSign = (dot(normalize(cross(normal, tangent)), bitangent) < 0.0) ? -1.0 : 1.0;

        vec3 modelScale = vec3(length(modelNodeMatrix[0].xyz), length(modelNodeMatrix[1].xyz), length(modelNodeMatrix[2].xyz));

        outVertices[vertexIndex] = OutPackedVertex(
          /*outPackedVertex.positionNormalXY =*/ uvec4(
            uvec3(floatBitsToUint(position.xyz)), 
            packSnorm2x16(normal.xy)
          ),
          /* outPackedVertex.normalZSignTangentXYZModelScaleXYZ = */uvec4(
            packSnorm2x16(vec2(normal.z, tbnSign)), 
            packSnorm2x16(tangent.xy), 
            (packSnorm2x16(vec2(tangent.z, 0.0)) & 0xffffu) | (packHalf2x16(vec2(0.0, modelScale.x)) & 0xffff0000u),
            packHalf2x16(modelScale.yz)
          )
        );

        outGenerations[vertexIndex] = inGeneration;

      }

#ifdef RAYTRACING
      {
        // For ray tracing we need the position in model space, not world space, since BLAS references have transform matrices already, so
        // we can't transform them again with modelNodeMatrix, which includes also the world space model transform, nodeMatrix is without that.
        vec4 p = nodeMatrix * vec4(position.xyz, 1.0);
        position = p.xyz / p.w;
        OutRayTracingVertex outRayTracingVertex;
        outRayTracingVertex.position = uvec4(uvec3(floatBitsToUint(position.xyz)), 0u);
        outRayTracingVertices[vertexIndex] = outRayTracingVertex;
      }
#endif

    }

  }

}

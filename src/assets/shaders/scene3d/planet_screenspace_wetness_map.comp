#version 450 core

#pragma shader_stage(compute)

// This shader generates the wetness map for the planet in a screenspace manner, where the wetness map
// is used by the forward rendering pass to apply wetness effects on the planet's surface.
// It uses the rain and atmosphere maps to determine the wetness factor at each pixel on the screen.

// If no wetness is used at all, the engine provides a dummy 16x16 wetness map with all values set to 0.0, 
// so that the forward rendering pass can still render the planet without any wetness effects and without
// modification of the shader code. Indeed, not super efficient, but it works for now, as the dummy
// wetness map is very small, so it does not take much memory and does not affect performance significantly.

// And as additional note, this shader needs a pre-resolved depth map, when MSAA is used. And for wetness
// the discontinuity of the depth map at antialiasing edges is not a problem, as wet areas are usually large and
// smooth transitions, so the discontinuity of the depth map does not affect the wetness map significantly.
// Otherwise just tolerate it for now. 

// The wetness map is initialized with 0.0 values, so that multiple planets could be present in the scene, and
// we don't write never 0.0 values, just greater than 0.0 values. And we ignore Z-fighting situations
// between planets for now, as we don't want to complicate the shader code with additional checks for that. 

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

// XY = screen space coordinates, Z = view index if multiview is enabled
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Render instance descriptor set (for the wetness map and depth map)

#ifdef MULTIVIEW

layout(set = 0, binding = 0, r8) uniform image2DArray uWetnessMap;

layout(set = 0, binding = 1) uniform sampler2DArray uDepthMap;

#else

layout(set = 0, binding = 0, r8) uniform image2D uWetnessMap;

layout(set = 0, binding = 1) uniform sampler2D uDepthMap;

#endif

// Planet descriptor set (for the rain and atmosphere maps)

layout(set = 1, binding = 0) uniform sampler2D uRainMap;

layout(set = 1, binding = 1) uniform sampler2D uAtmosphereMap;

// View descriptor set (for the view matrices)

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 2, binding = 0, std140) uniform uboViews {
  View views[256];
} uView;

// Push constants
layout(push_constant) uniform PushConstants {
  mat4 planetInverseModelMatrix; // Inverse model matrix of the planet
  vec4 occlusionOBBCenter; 
  vec4 occlusionOBBHalfSize;
  vec4 occlusionOBBOrientation;
  float planetRadius; // Radius of the planet including atmosphere and so on
  uint viewBaseIndex; // Base index for the view in multiview mode
  uint countViews; // Number of views in multiview mode
  uint countAllViews; // Total number of views in the scene
} pushConstants;

/* clang-format on */

#include "octahedral.glsl"
#include "octahedralmap.glsl"

bool ProjectionMatrixIsReversedZ(const in mat4 projectionMatrix){
  return projectionMatrix[2][3] < -1e-7;
}

bool ProjectionMatrixIsInfiniteFarPlane(const in mat4 projectionMatrix){
  return ProjectionMatrixIsReversedZ(projectionMatrix) && ((abs(projectionMatrix[2][2]) < 1e-7) && (abs(projectionMatrix[3][2]) > 1e-7));
}

float GetZFarDepthValue(const in mat4 projectionMatrix){
  return ProjectionMatrixIsReversedZ(projectionMatrix) ? 0.0 : 1.0;
}

#include "quaternion.glsl"

// A point is occluded if it is inside the OBB defined by the occlusionOBBCenter, occlusionOBBHalfSize, and occlusionOBBOrientation.
// For to check if a point is inside a building or other occluder, where rain streaks should not be rendered. 
bool isOccluded(vec3 position){
  if(pushConstants.occlusionOBBHalfSize.w > 0.5){ 
    vec3 p = transformVectorByQuaternion(position.xyz - pushConstants.occlusionOBBCenter.xyz, pushConstants.occlusionOBBOrientation);
    return all(lessThanEqual(abs(p), pushConstants.occlusionOBBHalfSize.xyz));
  }else{
    return false; // OBB is not defined, so no occlusion
  }
}

// Returns a factor for how much the rain streak should be occluded based on its position relative to the OBB. When inside the OBB, the
// factor is 0.0 (invisible), and when outside the OBB, the factor is 1.0 (fully visible). The factor is smoothstep-ed to avoid hard edges.
float visibilityFactor(vec3 position){
  if(pushConstants.occlusionOBBHalfSize.w > 0.5){ 
    vec3 p = transformVectorByQuaternion(position.xyz - pushConstants.occlusionOBBCenter.xyz, pushConstants.occlusionOBBOrientation);
    vec3 q = abs(p) - pushConstants.occlusionOBBHalfSize.xyz;
    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
    return smoothstep(0.0, length(pushConstants.occlusionOBBHalfSize.xyz) * 0.03125, d);  
  }else{
    return 1.0; // OBB is not defined, so no occlusion
  }
}

void main() {

#ifdef MULTIVIEW
  
  uvec3 screenSpaceCoordinates = uvec3(gl_GlobalInvocationID.xyz);
  uvec3 screenSize = uvec3(imageSize(uWetnessMap).xyz);

#else
  
  uvec2 screenSpaceCoordinates = uvec2(gl_GlobalInvocationID.xy);
  uvec2 screenSize = uvec2(imageSize(uWetnessMap).xy);

#endif

  if(any(greaterThanEqual(screenSpaceCoordinates, screenSize))) {
    // If the screen space coordinates are out of bounds, do nothing
    return;
  }

  // Get the right view index for the matrices
  uint viewIndex = pushConstants.viewBaseIndex; 
#ifdef MULTIVIEW
  viewIndex += screenSpaceCoordinates.z;
#endif

  // Get the inverse view and inverse projection matrices for the current view
  mat4 inverseViewMatrix = uView.views[viewIndex].inverseViewMatrix;
  mat4 inverseProjectionMatrix = uView.views[viewIndex].inverseProjectionMatrix;

  // Get the Z Far depth value based on the projection matrix
  float zFarDepthValue = GetZFarDepthValue(uView.views[viewIndex].projectionMatrix); 

  // Combine the inverse matrices to get the inverse view-projection matrix
  mat4 inverseViewProjectionMatrix = inverseProjectionMatrix * inverseViewMatrix;

  // Calculate NDC coordinates
  vec2 uv = fma((vec2(screenSpaceCoordinates.xy) + vec2(0.5)) / vec2(screenSize.xy), vec2(2.0), vec2(-1.0));

  // Fetch depth value from the depth map
#ifdef MULTIVIEW
  float depthValue = textureLod(uDepthMap, vec3(uv, screenSpaceCoordinates.z), 0.0).x;
#else  
  float depthValue = textureLod(uDepthMap, uv, 0.0).x;
#endif

  // If the depth is Z Far, we can skip further calculations, because there is no wetness at this depth
  if(depthValue >= zFarDepthValue){
    return;
  }

  // Convert depth value to clip space coordinates
  vec4 clipSpaceCoordinates = vec4(fma(uv, vec2(0.5), vec2(0.5)), depthValue, 1.0);
  
  // Convert clip space coordinates to world space coordinates
  vec4 worldSpaceCoordinates = inverseViewProjectionMatrix * clipSpaceCoordinates;
  worldSpaceCoordinates /= worldSpaceCoordinates.w;

  // Convert world space coordinates to planet space by applying the inverse model matrix
  vec3 planetSpaceCoordinates = (pushConstants.planetInverseModelMatrix * worldSpaceCoordinates).xyz;

  // Calculate the distance from the center of the planet
  float distanceFromCenter = length(planetSpaceCoordinates);

  // If the distance is greater than the planet radius, we can skip further calculations, because there is no wetness at this distance
  if (distanceFromCenter > pushConstants.planetRadius) {
    return;
  }

  // Get the rain and atmosphere map values
  float rainFactor = texturePlanetOctahedralMap(uRainMap, planetSpaceCoordinates).x;
  float atmosphereFactor = texturePlanetOctahedralMap(uAtmosphereMap, planetSpaceCoordinates).x;

  // Combine the rain factor and atmosphere factor into a single combined rain atmosphere factor 
  // The visibility factor is applied to the rain atmosphere factor to account for occlusion by buildings or other objects in local view,
  // for example, when the camera is inside a building or under a roof, the rain should not be at this position.
  float rainAtmosphereFactor = rainFactor * atmosphereFactor * visibilityFactor(planetSpaceCoordinates);

  // Store this factor in the wetness map. when greater than 0.0
  if(rainAtmosphereFactor > 0.0){
#ifdef MULTIVIEW
    imageStore(uWetnessMap, ivec3(screenSpaceCoordinates), vec4(rainAtmosphereFactor));
#else
    imageStore(uWetnessMap, ivec2(screenSpaceCoordinates), vec4(rainAtmosphereFactor));
#endif
  }

}

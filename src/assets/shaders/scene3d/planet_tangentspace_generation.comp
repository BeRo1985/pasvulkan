#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, r32f) readonly uniform image2D uImageHeightMap;
layout(set = 0, binding = 1, rg16_snorm) writeonly uniform image2D uImageNormalMap;
layout(set = 0, binding = 2, rgba16_snorm) writeonly uniform image2D uImageTangentBitangentMap;

/* clang-format on */

layout(push_constant) uniform PushConstants {
  float planetGroundRadius; // planet ground radius
  float heightMapScale; // scale of height map
} pushConstants;

#include "octahedralmap.glsl"
#include "octahedral.glsl"
#include "tangentspacebasis.glsl"

ivec2 texSize;

float getBilinearHeight(vec2 v){
  v *= texSize;
  ivec2 i = ivec2(floor(v));
  vec2 f = v - vec2(i);
  return mix(mix(imageLoad(uImageHeightMap, wrapOctahedralTexelCoordinates(i + ivec2(0, 0), texSize)).x, 
                 imageLoad(uImageHeightMap, wrapOctahedralTexelCoordinates(i + ivec2(1, 0), texSize)).x, f.x), 
             mix(imageLoad(uImageHeightMap, wrapOctahedralTexelCoordinates(i + ivec2(0, 1), texSize)).x,
                 imageLoad(uImageHeightMap, wrapOctahedralTexelCoordinates(i + ivec2(1, 1), texSize)).x, f.x), f.y);
}

void main(){
  
  ivec2 texel = ivec2(gl_GlobalInvocationID.xy);

  texSize = imageSize(uImageHeightMap);

  if(all(greaterThanEqual(texel, ivec2(0))) && all(lessThan(texel, texSize))){

    vec2 invTexSize = vec2(1.0) / vec2(texSize);  

#if 0

#if 0
    float stepSize = distance(octDecode(fma(vec2(wrapOctahedralTexelCoordinates(texel + ivec2(-1, -1), texSize)) * invTexSize, vec2(2.0), vec2(-1.0))),
                              octDecode(fma(vec2(wrapOctahedralTexelCoordinates(texel + ivec2(1, 1), texSize)) * invTexSize, vec2(2.0), vec2(-1.0)))) * 0.25;
#else
    float stepSize = max(invTexSize.x, invTexSize.y);
#endif

    vec2 center = vec2(texel) * invTexSize;

    vec3 sphereNormal = octDecode(fma(center, vec2(2.0), vec2(-1.0)));

    float theta = atan(sphereNormal.z, sphereNormal.x), phi = asin(sphereNormal.y);
    vec3 sphereTangent = normalize(vec3(cos(theta) * sin(phi),
                                        -cos(phi),
                                        sin(theta) * sin(phi)));
    vec3 sphereBitangent = normalize(vec3(sin(theta) * cos(phi),
                                          0.0,
                                          -cos(theta) * cos(phi)));
    sphereTangent = normalize(cross(normalize(sphereBitangent - (dot(sphereBitangent, sphereNormal) * sphereNormal)), sphereNormal));
    sphereBitangent = normalize(cross(sphereNormal, sphereTangent));

    vec2 t00 = fma(octEncode(normalize(sphereNormal + (sphereTangent * (-stepSize)))), vec2(0.5), vec2(0.5));
    vec2 t01 = fma(octEncode(normalize(sphereNormal + (sphereTangent * stepSize))), vec2(0.5), vec2(0.5));
    vec2 t10 = fma(octEncode(normalize(sphereNormal + (sphereBitangent * (-stepSize)))), vec2(0.5), vec2(0.5));
    vec2 t11 = fma(octEncode(normalize(sphereNormal + (sphereBitangent * stepSize))), vec2(0.5), vec2(0.5));

    vec3 p00 = octDecode(fma(t00, vec2(2.0), vec2(-1.0))) * fma(getBilinearHeight(t00), pushConstants.heightMapScale / pushConstants.planetGroundRadius, 1.0);
    vec3 p01 = octDecode(fma(t01, vec2(2.0), vec2(-1.0))) * fma(getBilinearHeight(t01), pushConstants.heightMapScale / pushConstants.planetGroundRadius, 1.0);
    vec3 p10 = octDecode(fma(t10, vec2(2.0), vec2(-1.0))) * fma(getBilinearHeight(t10), pushConstants.heightMapScale / pushConstants.planetGroundRadius, 1.0);
    vec3 p11 = octDecode(fma(t11, vec2(2.0), vec2(-1.0))) * fma(getBilinearHeight(t11), pushConstants.heightMapScale / pushConstants.planetGroundRadius, 1.0);
    
#else

    ivec2 xy00 = wrapOctahedralTexelCoordinates(texel + ivec2(-1, 0), texSize);
    ivec2 xy01 = wrapOctahedralTexelCoordinates(texel + ivec2(1, 0), texSize);
    ivec2 xy10 = wrapOctahedralTexelCoordinates(texel + ivec2(0, -1), texSize);
    ivec2 xy11 = wrapOctahedralTexelCoordinates(texel + ivec2(0, 1), texSize);

    float scaleFactor = pushConstants.heightMapScale / pushConstants.planetGroundRadius;

    vec3 p00 = octDecode(fma(vec2(xy00) * invTexSize, vec2(2.0), vec2(-1.0))) * fma(imageLoad(uImageHeightMap, xy00).x, scaleFactor, 1.0);
    vec3 p01 = octDecode(fma(vec2(xy01) * invTexSize, vec2(2.0), vec2(-1.0))) * fma(imageLoad(uImageHeightMap, xy01).x, scaleFactor, 1.0);
    vec3 p10 = octDecode(fma(vec2(xy10) * invTexSize, vec2(2.0), vec2(-1.0))) * fma(imageLoad(uImageHeightMap, xy10).x, scaleFactor, 1.0);
    vec3 p11 = octDecode(fma(vec2(xy11) * invTexSize, vec2(2.0), vec2(-1.0))) * fma(imageLoad(uImageHeightMap, xy11).x, scaleFactor, 1.0);
#endif

    vec3 tangent = normalize(p01 - p00);
    vec3 bitangent = normalize(p11 - p10);
    vec3 normal = normalize(cross(tangent, bitangent));
    
#if 0
    tangent = normalize(cross(normalize(bitangent - (dot(bitangent, normal) * normal)), normal));
    bitangent = normalize(cross(normal, tangent));
#endif

#if 0
    getTangentSpaceBasisFromNormal(normal, tangent, bitangent); 
#endif

#if 1
    // The tangent and bitangent vectors are derived from the surface normal using spherical coordinates.
    //
    // The surface normal is assumed to be normalized and represented as 'normal', where its components are (x, y, z).
    // The spherical coordinates (theta, phi) are derived from the normal.
    // Theta is the angle from the z-axis, calculated using asin(normal.y).
    // Phi is the angle from the x-axis in the xy-plane, calculated using atan(normal.z, normal.x).
    // To get the tangent (T), we calculate the partial derivative of P with respect to phi (∂P/∂phi),
    // which, after simplification (ignoring the radius r), gives us T = (-sin(phi), 0, cos(phi)).
    // For the bitangent (B), we calculate the partial derivative of P with respect to theta (∂P/∂theta),
    // which simplifies to B = (cos(theta)cos(phi), -sin(theta), cos(theta)sin(phi)).
    //
    // Or more in detail:
    //
    // The tangent (T) and bitangent (B) are calculated using the derivatives of spherical coordinates.
    //
    // For a point P on a sphere, expressed in spherical coordinates (r, theta, phi), where:
    // Px = r * cos(theta) * cos(phi)
    // Py = r * sin(theta)
    // Pz = r * cos(theta) * sin(phi)
    //
    // The tangent T is obtained by differentiating P with respect to phi:
    // T = ∂P/∂phi = vec3(-r * cos(theta) * sin(phi), 0, r * cos(theta) * cos(phi))
    // After normalizing and ignoring the radius r (since it cancels out), we have:
    // T = vec3(-sin(phi), 0, cos(phi))
    //
    // Similarly, the bitangent B is obtained by differentiating P with respect to theta:
    // B = ∂P/∂theta = vec3(-r * sin(theta) * cos(phi), r * cos(theta), -r * sin(theta) * sin(phi))
    // Again, normalizing and ignoring r gives us:
    // B = vec3(-sin(theta) * cos(phi), cos(theta), -sin(theta) * sin(phi))
    //
    vec4 sinCosThetaPhi = sin(vec4(vec2(atan(normal.z, normal.x), asin(normal.y)).xxyy + vec2(0.0, 1.5707963267948966).xyxy));
    tangent = normalize(vec3(sinCosThetaPhi.x * sinCosThetaPhi.w, 0.0, -sinCosThetaPhi.y * sinCosThetaPhi.w));
    bitangent = normalize(vec3(sinCosThetaPhi.y * sinCosThetaPhi.z, -sinCosThetaPhi.w, sinCosThetaPhi.x * sinCosThetaPhi.z));
  //tangent = normalize(cross(normalize(bitangent - (dot(bitangent, normal) * normal)), normal));
  //bitangent = normalize(cross(normal, tangent));
#endif

    imageStore(uImageNormalMap, texel, vec3(octEncode(normal), 0.0).xyzz);

    imageStore(uImageTangentBitangentMap, texel, vec4(octEncode(tangent), octEncode(bitangent)));

  }

}
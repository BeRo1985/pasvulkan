#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* clang-format on */

#define MULTISCATAPPROX_ENABLED
#undef SHADOWS_ENABLED

#include "atmosphere_common.glsl"

// Push constants
layout(push_constant, std140) uniform PushConstants {
  int baseViewIndex;
  int countViews;
  int sliceID;
  int dummy1;
  vec4 sunDirection;
  vec2 resolution;
} pushConstants;

layout(set = 0, binding = 0, rgba32f) uniform image2DArray uDestinationTexture;

layout(set = 0, binding = 1) uniform sampler2DArray uTransmittanceLutTexture;

layout(set = 0, binding = 2) uniform sampler2DArray uMultiScatTexture;

layout(set = 0, binding = 3, std430) buffer AtmosphereParametersBuffer {
  InAtmosphereParameters inAtmosphereParameters;
} uAtmosphereParameters;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 1, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

AtmosphereParameters atmosphereParameters;
 
void main() {

  ivec2 size = imageSize(uDestinationTexture).xy;

  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  int globalZ = int(gl_GlobalInvocationID.z);

  int viewIndex = pushConstants.baseViewIndex + int(globalZ / AP_SLICE_COUNT_INT);

  int sliceIndex = globalZ % AP_SLICE_COUNT_INT;
  
  if(all(greaterThanEqual(coord, ivec2(0))) && all(lessThan(coord, size)) && (viewIndex < pushConstants.countViews)) {

    atmosphereParameters = getAtmosphereParameters(uAtmosphereParameters.inAtmosphereParameters);

    mat4 inverseViewMatrix = uView.views[viewIndex].inverseViewMatrix;
    mat4 inverseProjectionMatrix = uView.views[viewIndex].inverseProjectionMatrix;

    gSkyInvViewProjMat = inverseProjectionMatrix * inverseViewMatrix;

    gResolution = pushConstants.resolution;

    int sliceID = sliceIndex;

    vec3 ClipSpace = vec3(fma(vec2(coord) / vec2(gResolution), vec2(2.0), vec2(-1.0)), 0.5);
    vec4 HViewPos = inverseProjectionMatrix * vec4(ClipSpace, 1.0);
    vec3 WorldDir = normalize(mat3(inverseViewMatrix) * (HViewPos.xyz / HViewPos.w));

    float earthR = atmosphereParameters.BottomRadius;
    vec3 earthO = vec3(0.0, 0.0, -earthR);
    vec3 camPos = vec3(0, 0, earthR);
    vec3 SunDir = pushConstants.sunDirection.xyz;
    vec3 SunLuminance = vec3(0.0);

    float Slice = ((float(sliceID) + 0.5) / float(AP_SLICE_COUNT));
    Slice *= Slice;	// squared distribution
    Slice *= AP_SLICE_COUNT;

    vec3 WorldPos = camPos;
    float viewHeight;

    // Compute position from froxel information
    float tMax = AerialPerspectiveSliceToDepth(Slice);
    vec3 newWorldPos = WorldPos + (tMax * WorldDir);

    // If the voxel is under the ground, make sure to offset it out on the ground.
    viewHeight = length(newWorldPos);
    if(viewHeight <= (atmosphereParameters.BottomRadius + PLANET_RADIUS_OFFSET)){
      // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
      newWorldPos = normalize(newWorldPos) * (atmosphereParameters.BottomRadius + PLANET_RADIUS_OFFSET + 0.001);
      WorldDir = normalize(newWorldPos - camPos);
      tMax = length(newWorldPos - camPos);
    }
    float tMaxMax = tMax;

    // Move ray marching start up to top atmosphere.
    viewHeight = length(WorldPos);
    if(viewHeight >= atmosphereParameters.TopRadius){
      vec3 prevWorlPos = WorldPos;
      if(!MoveToTopAtmosphere(WorldPos, WorldDir, atmosphereParameters.TopRadius)){
        // Ray is not intersecting the atmosphere
        imageStore(uDestinationTexture, ivec3(coord, viewIndex), vec4(0.0, 0.0, 0.0, 1.0));
        return;
      }
      float LengthToAtmosphere = length(prevWorlPos - WorldPos);
      if(tMaxMax < LengthToAtmosphere){
        // tMaxMax for this voxel is not within earth
        imageStore(uDestinationTexture, ivec3(coord, viewIndex), vec4(0.0, 0.0, 0.0, 1.0));
        return;
      }
      // Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
      tMaxMax = max(0.0, tMaxMax - LengthToAtmosphere);
    }

    const bool ground = false;
    const float SampleCountIni = max(1.0, float(sliceID + 1) * 2.0);
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(
      uTransmittanceLutTexture,
      uMultiScatTexture,
      viewIndex,
      coord, 
      WorldPos, 
      WorldDir, 
      SunDir, 
      atmosphereParameters, 
      ground, 
      SampleCountIni, 
      DepthBufferValue, 
      VariableSampleCount, 
      MieRayPhase,
      tMaxMax
    );

    vec3 L = ss.L;
    const float Transmittance = dot(ss.Transmittance, vec3(1.0 / 3.0));
    imageStore(uDestinationTexture, ivec3(coord, (viewIndex * AP_SLICE_COUNT_INT) + sliceID), vec4(L, 1.0 - Transmittance));

  }

}


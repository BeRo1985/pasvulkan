#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* clang-format on */

#define MULTISCATAPPROX_ENABLED
#undef SHADOWS_ENABLED

#include "atmosphere_common.glsl"

// Push constants
layout(push_constant, std140) uniform PushConstants {
  int baseViewIndex;
  int countViews;
  int dummy0;
  int dummy1;
} pushConstants;

layout(set = 0, binding = 0, rgba32f) uniform image2DArray uDestinationTexture;

layout(set = 0, binding = 1) uniform sampler2D uTransmittanceLutTexture;

layout(set = 0, binding = 2) uniform sampler2DArray uMultiScatTexture;

layout(set = 0, binding = 3, std430) buffer AtmosphereParametersBuffer {
  AtmosphereParameters atmosphereParameters;
} uAtmosphereParameters;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 1, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

AtmosphereParameters atmosphereParameters;
 
void main() {

  ivec2 size = imageSize(uDestinationTexture).xy;

  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  int globalZ = int(gl_GlobalInvocationID.z);

  int viewIndex = int(globalZ / AP_SLICE_COUNT_INT);

  int sliceIndex = globalZ % AP_SLICE_COUNT_INT;
  
  if(all(greaterThanEqual(coord, ivec2(0))) && all(lessThan(coord, size)) && (viewIndex < pushConstants.countViews)) {

    atmosphereParameters = uAtmosphereParameters.atmosphereParameters;

    View view = uView.views[pushConstants.baseViewIndex + viewIndex];

    mat4 inverseViewMatrix = view.inverseViewMatrix;
    mat4 inverseProjectionMatrix = view.inverseProjectionMatrix;

    mat4 skyInvViewProjMat = inverseViewMatrix * inverseProjectionMatrix;

    int sliceID = sliceIndex;

    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(size);

    vec3 worldPos, worldDir;
    GetCameraPositionDirection(worldPos, worldDir, view.viewMatrix, view.projectionMatrix, view.inverseViewMatrix, view.inverseProjectionMatrix, uv);

    worldPos = (atmosphereParameters.inverseTransform * vec4(worldPos, 1.0)).xyz;

    float earthR = atmosphereParameters.BottomRadius;
    vec3 earthO = vec3(0.0, -earthR, 0.0);
    vec3 camPos = worldPos;// + vec3(0.0, earthR, 0.0);
    vec3 SunDir = getSunDirection(atmosphereParameters);
    vec3 SunLuminance = vec3(0.0);

    float Slice = ((float(sliceID) + 0.5) / float(AP_SLICE_COUNT));
    Slice *= Slice;	// squared distribution
    Slice *= AP_SLICE_COUNT;
    
    // (BeRo): Move ray marching start up to top atmosphere, for to avoid missing the atmosphere in the special case of the camera being
    // far outside the atmosphere.
    //if(length(worldPos) >= atmosphereParameters.TopRadius)
    {
      vec2 t = raySphereIntersect(worldPos, worldDir, vec3(0.0), atmosphereParameters.TopRadius);
      if(all(greaterThanEqual(t, vec2(0.0)))){
        worldPos += worldDir * min(t.x, t.y);
      }
    }

    // Compute position from froxel information
    float tMax = AerialPerspectiveSliceToDepth(Slice);
    vec3 newWorldPos = worldPos + (tMax * worldDir);

    // If the voxel is under the ground, make sure to offset it out on the ground.
    float viewHeight = length(newWorldPos);
    if(viewHeight <= (atmosphereParameters.BottomRadius + PLANET_RADIUS_OFFSET)){
      // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
      newWorldPos = normalize(newWorldPos) * (atmosphereParameters.BottomRadius + PLANET_RADIUS_OFFSET + 0.001);
      worldDir = normalize(newWorldPos - camPos);
      tMax = length(newWorldPos - camPos);
    }
    float tMaxMax = tMax;

    // Move ray marching start up to top atmosphere.
    viewHeight = length(worldPos);  
    if(viewHeight >= atmosphereParameters.TopRadius){
      vec3 previousWorldPosition = worldPos;
      if(!MoveToTopAtmosphere(worldPos, worldDir, atmosphereParameters.TopRadius)){
        // Ray is not intersecting the atmosphere
        imageStore(uDestinationTexture, ivec3(coord, (viewIndex * AP_SLICE_COUNT_INT) + sliceID), vec4(0.0, 0.0, 0.0, 0.0));
        return;
      }
      float LengthToAtmosphere = length(previousWorldPosition - worldPos);
      if(tMaxMax < LengthToAtmosphere){
        // tMaxMax for this voxel is not within earth
        imageStore(uDestinationTexture, ivec3(coord, (viewIndex * AP_SLICE_COUNT_INT) + sliceID), vec4(0.0, 0.0, 0.0, 0.0));
        return;
      }
      // Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
      tMaxMax = max(0.0, tMaxMax - LengthToAtmosphere);
    }

    const bool ground = false;
    const float SampleCountIni = max(1.0, float(sliceID + 1) * 2.0);
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(
      uTransmittanceLutTexture,
      uMultiScatTexture,
      viewIndex,
      uv, 
      worldPos, 
      worldDir, 
      SunDir, 
      atmosphereParameters, 
      ground, 
      SampleCountIni,  
      DepthBufferValue, 
      VariableSampleCount, 
      MieRayPhase,
      skyInvViewProjMat,
      tMaxMax,
      false
    ); 

    vec3 L = ss.L;
    const float Transmittance = dot(ss.Transmittance, vec3(1.0 / 3.0));
    imageStore(uDestinationTexture, ivec3(coord, (viewIndex * AP_SLICE_COUNT_INT) + sliceID), vec4(L, 1.0 - Transmittance));

  }

}


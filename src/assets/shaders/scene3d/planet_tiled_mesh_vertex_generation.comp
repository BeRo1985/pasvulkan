#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_ARB_gpu_shader_fp64 : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_samplerless_texture_functions : enable

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct TriangleVertex {
  vec4 positionAbsoluteHeight;
  vec4 normalRelativeHeight;
};

layout(set = 0, binding = 0, std430) buffer TriangleVertices {
  TriangleVertex vertices[]; // 32 bytes per vertex
} triangleVertices;

layout(set = 0, binding = 1, std430) buffer QueuedTiles {
  uint data[]; // 6-based, because two VkDispatchIndirectCommand structs are stored in the same buffer at the beginning, with three 32-bit unsigned integers each
} queuedTiles;

layout(set = 0, binding = 2) uniform texture2D uTextureHeightMap; // r32f

layout(set = 0, binding = 3) uniform texture2D uTextureNormalMap; // rgba16_snorm

layout(push_constant) uniform PushConstants {
  //mat4 modelMatrix;
  float bottomRadius;
  float topRadius;
  uint tileMapResolution;
  uint tileResolution;
  int lod;
} pushConstants;

#include "octahedral.glsl"

vec3 safeNormalize(vec3 v){
  return (length(v) > 0.0) ? normalize(v) : vec3(0.0);
}

void main(){

  const uint queuedTileIndex = uint(gl_GlobalInvocationID.y);
  
  const uint tileMapSize = pushConstants.tileMapResolution * pushConstants.tileMapResolution;

  if((queuedTileIndex < tileMapSize) && (queuedTileIndex < queuedTiles.data[1u])){

    const uint tileMapIndex = queuedTiles.data[queuedTileIndex + 6u];

    if(tileMapIndex < tileMapSize){

      uvec2 tileMapXY;
      tileMapXY.y = tileMapIndex / pushConstants.tileMapResolution;
      tileMapXY.x = tileMapIndex - (tileMapXY.y * pushConstants.tileMapResolution);

      const uint tileVertexSize = pushConstants.tileResolution * pushConstants.tileResolution;

      const uint tileVertexIndex = uint(gl_GlobalInvocationID.x);
      
      if(tileVertexIndex < tileVertexSize){

        uvec2 tileVertexXY;
        tileVertexXY.y = tileVertexIndex / pushConstants.tileResolution;
        tileVertexXY.x = tileVertexIndex - (tileVertexXY.y * pushConstants.tileResolution);

        uvec2 quadXY = (tileMapXY * pushConstants.tileResolution) + tileVertexXY;
        
        uint totalResolution = pushConstants.tileMapResolution * pushConstants.tileResolution;

#if 1
        // Variant that uses temporary neighbor vertices to calculate the normal

        vec4 vertices[3][3];
        for(int y = 0; y < 3; y++){
          for(int x = 0; x < 3; x++){
            ivec2 otherQuadXY = ivec2(quadXY) + ivec2(x - 1, y - 1);
            otherQuadXY = wrapOctahedralTexelCoordinates(otherQuadXY, ivec2(totalResolution));
            float height = texelFetch(uTextureHeightMap, ivec2(otherQuadXY), pushConstants.lod).x; 
            vertices[y][x] = vec4(octPlanetUnsignedDecode(vec2(otherQuadXY) / vec2(totalResolution)) * mix(pushConstants.bottomRadius, pushConstants.topRadius, height), height);
          }
        }
        // Calculate the normal as the average of the normals of some temporary virtual triangles
        // a(-1, -1) b( 0, -1) c( 1, -1)
        // d(-1,  0) e( 0,  0) f( 1,  0)
        // g(-1,  1) h( 0,  1) i( 1,  1)
        // Calculate the smoothed normal at point e as the average of the normals of the surrounding triangles in triangle fan order:
#define a vertices[0][0].xyz
#define b vertices[0][1].xyz
#define c vertices[0][2].xyz
#define d vertices[1][0].xyz
#define e vertices[1][1].xyz
#define f vertices[1][2].xyz
#define g vertices[2][0].xyz
#define h vertices[2][1].xyz
#define i vertices[2][2].xyz
        vec3 normal = safeNormalize(
          safeNormalize(cross(a - e, b - e)) + // Triangle EAB
          safeNormalize(cross(b - e, c - e)) + // Triangle EBC          
          safeNormalize(cross(c - e, f - e)) + // Triangle EDA
          safeNormalize(cross(f - e, i - e)) + // Triangle EFI
          safeNormalize(cross(i - e, h - e)) + // Triangle EIH
          safeNormalize(cross(h - e, g - e)) + // Triangle EHG
          safeNormalize(cross(g - e, d - e)) + // Triangle EGD
          safeNormalize(cross(d - e, a - e))   // Triangle EDA
        );          
#undef a
#undef b
#undef c
#undef d
#undef e
#undef f
#undef g
#undef h
#undef i

        float height = texelFetch(uTextureHeightMap, ivec2(quadXY), pushConstants.lod).x;

        triangleVertices.vertices[(tileMapIndex * tileVertexSize) + tileVertexIndex] = TriangleVertex( 
          vec4(vertices[1][1].xyz, length(vertices[1][1].xyz)), 
          vec4(normal, vertices[1][1].w)
        );    


#else

        // Variant that uses the height map to get the normal directly, but it has some artifacts in the moment at some edge cases => TODO: fix it

        float height = texelFetch(uTextureHeightMap, ivec2(quadXY), pushConstants.lod).x;

        triangleVertices.vertices[(tileMapIndex * tileVertexSize) + tileVertexIndex] = TriangleVertex( 
          vec4(vec4(octPlanetUnsignedDecode(vec2(quadXY) / vec2(totalResolution)), 1.0) * mix(pushConstants.bottomRadius, pushConstants.topRadius, height)), 
          vec4(normalize(texelFetch(uTextureNormalMap, ivec2(quadXY), pushConstants.lod).xyz), height)
        );    

#endif        

      }
    
    }

  }

}
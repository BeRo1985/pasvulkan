#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_ARB_gpu_shader_fp64 : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct TriangleVertex {
  vec4 positionAbsoluteHeight;
  vec4 normalRelativeHeight;
};

layout(set = 0, binding = 0, std430) buffer TriangleVertices {
  TriangleVertex vertices[]; // 32 bytes per vertex
} triangleVertices;

layout(set = 0, binding = 1, std430) buffer QueuedTiles {
  uint data[]; // 6-based, because two VkDispatchIndirectCommand structs are stored in the same buffer at the beginning, with three 32-bit unsigned integers each
} queuedTiles;

layout(set = 0, binding = 2) uniform sampler2D uTextureHeightMap; // r32f

layout(set = 0, binding = 3) uniform sampler2D uTextureNormalMap; // rgba16_snorm

layout(push_constant) uniform PushConstants {
  //mat4 modelMatrix;
  float bottomRadius;
  float topRadius;
  uint tileMapResolution;
  uint tileResolution;
  int lod;
} pushConstants;

#include "octahedral.glsl"

void main(){

  const uint queuedTileIndex = uint(gl_GlobalInvocationID.y);
  
  const uint tileMapSize = pushConstants.tileMapResolution * pushConstants.tileMapResolution;

  if((queuedTileIndex < tileMapSize) && (queuedTileIndex < queuedTiles.data[1u])){

    const uint tileMapIndex = queuedTiles.data[queuedTileIndex + 6u];

    if(tileMapIndex < tileMapSize){

      uvec2 tileMapXY;
      tileMapXY.y = tileMapIndex / pushConstants.tileMapResolution;
      tileMapXY.x = tileMapIndex - (tileMapXY.y * pushConstants.tileMapResolution);

      const uint tileVertexSize = pushConstants.tileResolution * pushConstants.tileResolution;

      const uint tileVertexIndex = uint(gl_GlobalInvocationID.x);
      
      if(tileVertexIndex < tileVertexSize){

        uvec2 tileVertexXY;
        tileVertexXY.y = tileVertexIndex / pushConstants.tileResolution;
        tileVertexXY.x = tileVertexIndex - (tileVertexXY.y * pushConstants.tileResolution);

        uvec2 quadXY = (tileMapXY * pushConstants.tileResolution) + tileVertexXY;
        
        uint totalResolution = pushConstants.tileMapResolution * pushConstants.tileResolution;

        float height = texelFetch(uTextureHeightMap, ivec2(quadXY), pushConstants.lod).x;

        triangleVertices.vertices[(tileMapIndex * tileVertexSize) + tileVertexIndex] = TriangleVertex( 
          vec4(vec4(octPlanetUnsignedDecode(vec2(quadXY) / vec2(totalResolution)), 1.0) * mix(pushConstants.bottomRadius, pushConstants.topRadius, height)), 
          vec4(normalize(texelFetch(uTextureNormalMap, ivec2(quadXY), pushConstants.lod).xyz), height)
        );    

      }
    
    }

  }

}
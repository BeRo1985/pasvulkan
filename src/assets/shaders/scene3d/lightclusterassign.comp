#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(push_constant, std140, row_major) uniform PushConstants {
  uvec4 tileSizeZNearZFar; 
  vec4 viewRect;
  uvec4 countLightsViewIndexSize;
} pushConstants;

struct AABB {
  vec4 minBounds;
  vec4 maxBounds; 
};

struct LightMetaInfo {
  vec4 minBounds; // xyz = min. pos, w = active state
  vec4 maxBounds; // xyz = max. pos, w = unused
};

layout(std430, set = 0, binding = 0) buffer Clusters {
  AABB clusterAABBs[];
};

layout(std430, set = 0, binding = 1) buffer LightMetaInfos {
  LightMetaInfo lightMetaInfos[];
};

layout (std430, binding = 2) buffer LightGridIndexList {
  uint lightGridIndexList[];
};

layout (std430, binding = 3) buffer LightGridClusters {
  uvec2 lightGridClusters[];
};

layout (std430, binding = 4) buffer LightGridIndexListCounter {
  uint lightGridIndexListCounter;
};

/* clang-format on */

shared LightMetaInfo sharedLightMetaInfos[8 * 8 * 8];

void main() {
  
  uint localInvocationIndex = uint(gl_LocalInvocationIndex);

  uvec3 globalInvocationID = uvec3(gl_GlobalInvocationID.xyz); //(gl_WorkGroupID.xyz * gl_WorkGroupSize.xyz) + gl_LocalInvocationID.xyz; 
  uvec3 globalSize = uvec3(gl_NumWorkGroups.xyz * gl_WorkGroupSize.xyz); 
  uint globalInvocationIndex = (((globalInvocationID.z * globalSize.y) + globalInvocationID.y) * globalSize.x) + globalInvocationID.x;
 
  uint clusterIndex = globalInvocationIndex + (pushConstants.countLightsViewIndexSize.y * pushConstants.countLightsViewIndexSize.z);

  uint countThreads = int(gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z);
  uint countLights = pushConstants.countLightsViewIndexSize.x;
  uint countBatches = (countLights + (countThreads - 1u)) / countThreads;

  uint countVisibleLights = 0u;
  uint visibleLightIndices[128];
  
  for(uint batchIndex = 0; batchIndex < countBatches; batchIndex++){
    uint linuxTransferIndex = (batchIndex * countThreads) + localInvocationIndex;
    if(linuxTransferIndex < countLights){
      sharedLightMetaInfos[localInvocationIndex] = lightMetaInfos[linuxTransferIndex];
    }else{
      sharedLightMetaInfos[localInvocationIndex] = LightMetaInfo(vec4(0.0), vec4(0.0));
    } 
    barrier();
    for(uint lightProcessIndex = 0u; lightProcessIndex < countThreads; lightProcessIndex++){
      if(sharedLightMetaInfos[lightProcessIndex].minBounds.w > 0.5){
        vec3 clusterAABBMin = clusterAABBs[clusterIndex].minBounds.xyz;
        vec3 clusterAABBMax = clusterAABBs[clusterIndex].maxBounds.xyz;
        vec3 lightAABBMin = sharedLightMetaInfos[localInvocationIndex].minBounds.xyz;
        vec3 lightAABBMax = sharedLightMetaInfos[localInvocationIndex].minBounds.xyz;
        if ((countVisibleLights < 128u) && 
            (all(lessThanEqual(clusterAABBMin, lightAABBMax)) && all(lessThanEqual(lightAABBMin, clusterAABBMax)))){          
          visibleLightIndices[countVisibleLights++] = (batchIndex * countThreads) + lightProcessIndex;
        }
      } 
    }
  }

  barrier();

  uint offset = atomicAdd(lightGridIndexListCounter, countVisibleLights);

  for(uint lightIndex = 0u; lightIndex < countVisibleLights; countVisibleLights++){
    lightGridIndexList[offset + lightIndex] = visibleLightIndices[lightIndex];
  }

  lightGridClusters[clusterIndex] = uvec2(offset, countVisibleLights);

}

// Path: src/assets/shaders/scene3d/ssao_gensamples.poca

// This script generates the sample points for the SSAO shader. The sample points are generated using a Halton sequence,
// which is a low-discrepancy sequence. The sequence is then normalized and the points are distributed in a sphere. 
// The distribution of the points can be controlled by the SAMPLE_DISTRIBUTION variable. The generated points are then 
// printed in the format required by the SSAO shader.

// Implemented in my own POCA scripting language, a ECMAScript-like scripting language but with some differences.

var SAMPLE_DISTRIBUTION = 2; // 0: LINEAR (r), 1: SQUARE (r^2), 2: LINEAR SQUARE HALFWAY (r * 0.5 + r^2 * 0.5 in normalized)

function radiusFunction(r) {
  const rmin = 0.05; // minimum radius
  const rmax = 1.00; // maximum radius
  
  switch (SAMPLE_DISTRIBUTION) {
    case 0:
      // Linear: r = r;
      break;
    case 1:
      r = r * r; // Square
      break;
    case 2:
      r = r * (r + 0.5) * (2.0 / 3.0); // Linear + square halfway, normalized
      break;
    default:
      throw "error: no / invalid sample distribution chosen";
  }
  
  return rmin + (rmax - rmin) * r;
}

function genSamples(count) {
  let samples = new Array(count * 4);
  for(let i = 0; i < count; i++) {
    samples[i * 4] = 0;
    samples[i * 4 + 1] = 0;
    samples[i * 4 + 2] = 0;
    samples[i * 4 + 3] = 0;
  } 
  
  let radius = 1.0;
  let zShift = 0.05 * radius; // bias into the z-direction
  
  let base = [3, 7, 5]; // Halton sequence base
  let offset = [0, 0, 0]; // Halton sequence offset
  
  let cx = 0, cy = 0; // Used to calculate center point
  let i = 0, j, k = 1;
  for (i = 0; i < count; k++) {
    for (j = 0; j < 3; j++) {
      let _i = k + offset[j];
      let _f = 1.0;
      let _r = 0.0;
      while (_i > 0) {
        _f = _f / base[j];
        _r = _r + _f * (_i % base[j]);
        _i = Math.floor(_i / base[j]);
      }
      samples[i * 4 + j] = _r * 2.0 - 1.0;
    }
    
    let l2 = samples[i * 4] ** 2 + samples[i * 4 + 1] ** 2 + samples[i * 4 + 2] ** 2;
    if (l2 > 1.0 || samples[i * 4 + 2] < 0) {
      continue; // Sample invalid, discard
    } else {
      cx += samples[i * 4];
      cy += samples[i * 4 + 1];
      i++;
    }
  }
  
  cx /= count;
  cy /= count;
  
  let l2max = 0;
  for (i = 0; i < count; i++) {
    samples[i * 4] -= cx;
    samples[i * 4 + 1] -= cy;
    
    let l2 = samples[i * 4] ** 2 + samples[i * 4 + 1] ** 2 + samples[i * 4 + 2] ** 2;
    if (l2 > l2max) {
      l2max = l2;
    }
  }
  
  let normlen = 1.0 / Math.sqrt(l2max);
  for (i = 0; i < count; i++) {
    let l = Math.sqrt(samples[i * 4] ** 2 + samples[i * 4 + 1] ** 2 + samples[i * 4 + 2] ** 2);
    let adjustedRadius = radiusFunction(l) / l * radius;
    
    samples[i * 4] *= adjustedRadius * normlen;
    samples[i * 4 + 1] *= adjustedRadius * normlen;
    samples[i * 4 + 2] *= adjustedRadius * normlen;
    
    samples[i * 4 + 2] += zShift;
  }
  
  // Format and print the samples
  print(`const int countKernelSamples = ${count};`, "\n");
  print(`const vec3 kernelSamples[${count}] = vec3[${count}](`, "\n");
  for (i = 0; i < count; i++) {
    print(`  vec3(${samples[i * 4]}, ${samples[i * 4 + 1]}, ${samples[i * 4 + 2]})${(i < count - 1) ? ',' : ''}`, "\n");
  }
  print(");\n");
}

print("// Generated by ssao_gensamples.poca\n");
print("#ifndef SSAO_SAMPLES_GLSL\n");
print("#define SSAO_SAMPLES_GLSL\n");
print("#if NUM_SAMPLES == 16\n");
genSamples(16);
print("#elif NUM_SAMPLES == 32\n");
genSamples(32);
print("#elif NUM_SAMPLES == 64\n");
genSamples(64);
print("#endif\n");
print("#endif\n");

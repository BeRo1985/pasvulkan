#version 450 core

#pragma shader_stage(compute)

// Water simulation based on "Fast Hydraulic Erosion Simulation and Visualization on GPU" by Xing Mei, Philippe Decaudin, Bao-Gang Hu
// Link: https://hal.inria.fr/inria-00402079/document

// But yet without the erosion part of the terrain part, just the water flow simulation for now.

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  float bottomRadius;
  float topRadius;
  uint planetHeightMapResolution;
  uint waterHeightMapResolution;
} pushConstants;

// This shader transforms the relative water height map buffer to an absolute water height map image for rendering.

layout(set = 0, binding = 0) uniform sampler2D uPlanetHeightmap;

layout(set = 0, binding = 1, std430) readonly buffer InWaterHeightMap {
  float values[];
} inWaterHeightMap;

layout(set = 0, binding = 2, r32f) writeonly uniform image2D uImageWaterMap;  

#include "octahedral.glsl"
#include "octahedralmap.glsl"

vec2 texelSize = 1.0 / vec2(pushConstants.waterHeightMapResolution);

vec2 readHeight(ivec2 p){
  p = clamp(wrapOctahedralTexelCoordinates(p, ivec2(pushConstants.waterHeightMapResolution)), ivec2(0), ivec2(pushConstants.waterHeightMapResolution - 1));
  return vec2(
    mix(
      pushConstants.bottomRadius,
      pushConstants.topRadius,
      (pushConstants.planetHeightMapResolution == pushConstants.waterHeightMapResolution) 
        ? texelFetch(uPlanetHeightmap, ivec2(p), 0).x // When the planet height map resolution is the same as the water height map resolution, we can just use texelFetch.
        : textureBicubicPlanetOctahedralMap(uPlanetHeightmap, vec2(p) * texelSize).x // Otherwise we need to use interpolation.
    ),  
    inWaterHeightMap.values[(p.y * pushConstants.waterHeightMapResolution) + p.x]
  );
} 

void main(){

  const uvec2 position = uvec2(gl_GlobalInvocationID.xy);

  if(all(lessThan(position, uvec2(pushConstants.waterHeightMapResolution)))){

    vec2 heights = readHeight(ivec2(position));
    float height = (heights.y < 1e-6) 
                     ? -1.0 // no water
                     : dot(heights, vec2(1.0)); // water
    
    imageStore(uImageWaterMap, ivec2(position), vec4(height));

  }

}
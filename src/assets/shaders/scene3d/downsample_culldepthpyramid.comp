#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

#ifdef MULTIPASS
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
#else
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
#endif

#ifdef MULTIVIEW
layout(set = 0, binding = 0) uniform sampler2DArray uSourceTexture; // Source mipmap level texture
#ifdef MULTIPASS
layout(set = 0, binding = 1, r32f) writeonly uniform image2DArray uDestinationTextures[]; // Destination mipmap level image
#else
layout(set = 0, binding = 1, r32f) writeonly uniform image2DArray uDestinationTexture; // Destination mipmap level image
#endif
#else
layout(set = 0, binding = 0) uniform sampler2D uSourceTexture; // Source mipmap level texture
#ifdef MULTIPASS
layout(set = 0, binding = 1, r32f) writeonly uniform image2D uDestinationTextures[]; // Destination mipmap level image
#else
layout(set = 0, binding = 1, r32f) writeonly uniform image2D uDestinationTexture; // Destination mipmap level image
#endif
#endif

/* clang-format on */

#ifdef REVERSEDZ
  #define reduceOp min
#else
  #define reduceOp max
#endif

#ifdef MULTIPASS
layout(push_constant) uniform PushConstants {
  int first;
  int countMipMapLevels;
} pushConstants;

shared float sharedZ[8 * 8];
#endif

void main() {
#ifdef MULTIPASS

  // Maximum four mipmap levels in a single pass, so more mip map levels require multiple passes divided by four mip maps, the remainder must be in
  // pushConstants.countMipMapLevels.

#ifdef MULTIVIEW
  ivec3 invocationPosition = ivec3(gl_GlobalInvocationID.xyz);
#else
  ivec2 invocationPosition = ivec2(gl_GlobalInvocationID.xy);
#endif
 
 vec4 depths;
 
 if(pushConstants.first != 0){
  
  ivec2 sourceSize = textureSize(uSourceTexture, 0).xy;

  ivec2 destinationTextureSize = imageSize(uDestinationTextures[0]).xy;

#ifdef MULTIVIEW
  if((sourceSize.x & 1) != 0){
    if((sourceSize.y & 1) != 0){
        // When width and height are odd, 4 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(reduceOp(textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.25, 0.25)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x,
                                      textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.75, 0.75)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x),
                             reduceOp(textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.25, 0.75)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x,
                                      textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.75, 0.25)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x)));
    }else{
      // When only width is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.25, 0.5)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x,
                             textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.75, 0.5)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x));
    }      
  }else{
    if((sourceSize.y & 1) != 0){
      // When only height is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.5, 0.25)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x,
                             textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.5, 0.75)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x));
    }else{
      // Otherwise when width and height are even, just one bilinear sample (with min or max sampler reduction filter) is used, since it is already 
      // perfectly 2x2.
      depths = vec4(textureLod(uSourceTexture, vec3((vec2(invocationPosition.xy) + vec2(0.5)) / vec2(destinationTextureSize), float(invocationPosition.z)), 0.0).x);
    }
  }
#else
  if((sourceSize.x & 1) != 0){
    if((sourceSize.y & 1) != 0){
        // When width and height are odd, 4 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(reduceOp(textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.25, 0.25)) / vec2(destinationTextureSize), 0.0).x,
                                      textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.75, 0.75)) / vec2(destinationTextureSize), 0.0).x),
                             reduceOp(textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.25, 0.75)) / vec2(destinationTextureSize), 0.0).x,
                                      textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.75, 0.25)) / vec2(destinationTextureSize), 0.0).x)));
    }else{
      // When only width is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.25, 0.5)) / vec2(destinationTextureSize), 0.0).x,
                             textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.75, 0.5)) / vec2(destinationTextureSize), 0.0).x));
    }      
  }else{
    if((sourceSize.y & 1) != 0){
      // When only height is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
      depths = vec4(reduceOp(textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.5, 0.25)) / vec2(destinationTextureSize), 0.0).x,
                             textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.5, 0.75)) / vec2(destinationTextureSize), 0.0).x));
    }else{
      // Otherwise when width and height are even, just one bilinear sample (with min or max sampler reduction filter) is used, since it is already 
      // perfectly 2x2.
      depths = vec4(textureLod(uSourceTexture, (vec2(invocationPosition.xy) + vec2(0.5)) / vec2(destinationTextureSize), 0.0).x);
    }
  }
#endif  

 }else{   
            
#ifdef MULTIVIEW
    depths = textureGather(uSourceTexture, vec3(vec2(vec2(invocationPosition.xy << 1) + vec2(0.5)) / vec2(ivec2(textureSize(uSourceTexture, 0).xy)), invocationPosition.z), 0);
#else
    depths = textureGather(uSourceTexture, vec2(vec2(invocationPosition.xy << 1) + vec2(0.5)) / vec2(ivec2(textureSize(uSourceTexture, 0).xy)), 0);
#endif
    depths = vec4(reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w)));
 
  }

  if(all(lessThan(invocationPosition.xy >> 0, imageSize(uDestinationTextures[0]).xy))){
#ifdef MULTIVIEW
    imageStore(uDestinationTextures[0], ivec3(invocationPosition.xy >> 0, invocationPosition.z), depths.xxxx);
#else
    imageStore(uDestinationTextures[0], invocationPosition.xy >> 0, depths.xxxx);
#endif
  }
  if(pushConstants.countMipMapLevels == 1){
    return;
  }

  int localInvocationIndex = int(gl_LocalInvocationIndex);

  sharedZ[localInvocationIndex] = depths.x;

  barrier();
  
  if((localInvocationIndex & 0x09 /*0b001001*/) == 0){
    depths.y = sharedZ[localInvocationIndex + 0x01];
    depths.z = sharedZ[localInvocationIndex + 0x08];
    depths.w = sharedZ[localInvocationIndex + 0x09];
    depths = vec4(reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w)));
    if(all(lessThan(invocationPosition.xy >> 1, imageSize(uDestinationTextures[1]).xy))){
#ifdef MULTIVIEW
      imageStore(uDestinationTextures[1], ivec3(invocationPosition.xy >> 1, invocationPosition.z), depths.xxxx);
#else
      imageStore(uDestinationTextures[1], invocationPosition.xy >> 1, depths.xxxx);
#endif
    }
    sharedZ[localInvocationIndex] = depths.x;
  }
  if(pushConstants.countMipMapLevels == 2){
    return;
  }
  barrier();

  if((localInvocationIndex & 0x1b /*0b011011*/) == 0){
    depths.y = sharedZ[localInvocationIndex + 0x02];
    depths.z = sharedZ[localInvocationIndex + 0x10];
    depths.w = sharedZ[localInvocationIndex + 0x12];
    depths = vec4(reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w)));
    if(all(lessThan(invocationPosition.xy >> 2, imageSize(uDestinationTextures[2]).xy))){
#ifdef MULTIVIEW
      imageStore(uDestinationTextures[2], ivec3(invocationPosition.xy >> 2, invocationPosition.z), depths.xxxx);
#else
      imageStore(uDestinationTextures[2], invocationPosition.xy >> 2, depths.xxxx);
#endif
    }
    sharedZ[localInvocationIndex] = depths.x;
  }
  if(pushConstants.countMipMapLevels == 3){
    return;
  }
  barrier();

  if((localInvocationIndex & 0x3f /*0b111111*/) == 0){
    depths.y = sharedZ[localInvocationIndex + 0x04];
    depths.z = sharedZ[localInvocationIndex + 0x20];
    depths.w = sharedZ[localInvocationIndex + 0x24];
    depths = vec4(reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w)));
    if(all(lessThan(invocationPosition.xy >> 3, imageSize(uDestinationTextures[3]).xy))){
#ifdef MULTIVIEW
      imageStore(uDestinationTextures[3], ivec3(invocationPosition.xy >> 3, invocationPosition.z), depths.xxxx);
#else
      imageStore(uDestinationTextures[3], invocationPosition.xy >> 3, depths.xxxx);
#endif
    }
  }
  
#else
#ifdef MULTIVIEW
  ivec3 invocationPosition = ivec3(gl_GlobalInvocationID.xyz);
  ivec2 xy = invocationPosition.xy;
  ivec3 destinationTextureSize = imageSize(uDestinationTexture);
  if (all(greaterThanEqual(invocationPosition, ivec3(0))) && all(lessThan(invocationPosition, destinationTextureSize)))
#else
  ivec2 invocationPosition = ivec2(gl_GlobalInvocationID.xy);
  ivec2 xy = invocationPosition.xy;
  ivec2 destinationTextureSize = imageSize(uDestinationTexture);
  if (all(greaterThanEqual(invocationPosition, ivec2(0))) && all(lessThan(invocationPosition, destinationTextureSize)))
#endif
  {
#ifdef MULTIVIEW
    int viewIndex = int(gl_GlobalInvocationID.z);
    float depth;
  #if MIPMAPLEVEL == 0
    // Special handling for the first mipmap level for including handling of non-power-of-two textures as source for the power-of-two first mip map level
    // of the hierarchical Z buffer.    
    ivec2 sourceSize = ivec2(textureSize(uSourceTexture, 0).xy);
    if((sourceSize.x & 1) != 0){
      if((sourceSize.y & 1) != 0){
         // When width and height are odd, 4 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
        depth = reduceOp(reduceOp(textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.25, 0.25)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x,
                                  textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.75, 0.75)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x),
                         reduceOp(textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.25, 0.75)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x,
                                  textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.75, 0.25)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x));
      }else{
        // When only width is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
        depth = reduceOp(textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.25, 0.5)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x,
                         textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.75, 0.5)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x);
      }      
    }else{
      if((sourceSize.y & 1) != 0){
        // When only height is odd, 2 bilinear samples (with min or max sampler reduction filter) are used to reduce undersampling.
        depth = reduceOp(textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.5, 0.25)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x,
                         textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.5, 0.75)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x);
      }else{
        // Otherwise when width and height are even, just one bilinear sample (with min or max sampler reduction filter) is used, since it is already 
        // perfectly 2x2.
        depth = textureLod(uSourceTexture, vec3((vec2(xy) + vec2(0.5)) / vec2(destinationTextureSize.xy), float(viewIndex)), 0.0).x;
      }
    }
  #else
      ivec3 sourceSize = ivec3(textureSize(uSourceTexture, 0).xyz);
      ivec3 sourceSizeMask = sourceSize - ivec3(1);
      ivec3 sourceXY = ivec3(xy.xy << ivec2(1), viewIndex);
    #if 1  
      vec4 depths = textureGather(uSourceTexture, vec3(vec2(vec2(sourceXY) + vec2(0.5)) / vec2(sourceSize.xy), sourceXY.z), 0);
      depth = reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w));
    #else
      depth = reduceOp(reduceOp(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 0, 0), ivec3(0), sourceSizeMask), 0).x,    //
                                texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 0, 0), ivec3(0), sourceSizeMask), 0).x),   //
                       reduceOp(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 1, 0), ivec3(0), sourceSizeMask), 0).x,    //
                                texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 1, 0), ivec3(0), sourceSizeMask), 0).x));  //
    #endif
  #endif
#else
    float depth;
  #if MIPMAPLEVEL == 0
     depth = texture(uSourceTexture, (vec2(xy) + vec2(0.5)) / vec2(destinationTextureSize.xy)).x;
  #else
      ivec2 sourceSize = ivec2(textureSize(uSourceTexture, 0).xy);
      ivec2 sourceSizeMask = sourceSize - ivec2(1);
      ivec2 sourceXY = xy << ivec2(1);
    #if 1  
      vec4 depths = textureGather(uSourceTexture, vec2(vec2(sourceXY) + vec2(0.5)) / vec2(sourceSize.xy), 0);
      depth = reduceOp(reduceOp(depths.x, depths.y), reduceOp(depths.z, depths.w));
    #else
      depth = reduceOp(reduceOp(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 0), ivec2(0), sourceSizeMask), 0).x,    //
                                texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 0), ivec2(0), sourceSizeMask), 0).x),   //
                       reduceOp(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 1), ivec2(0), sourceSizeMask), 0).x,    //
                                texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 1), ivec2(0), sourceSizeMask), 0).x));  //
    #endif
  #endif
#endif
    imageStore(uDestinationTexture, invocationPosition, vec4(depth));
  }
#endif  
}

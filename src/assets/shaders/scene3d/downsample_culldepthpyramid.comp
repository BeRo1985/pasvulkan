#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#ifdef MULTIVIEW
layout(set = 0, binding = 0) uniform sampler2DArray uSourceTexture; // Source mipmap level texture
layout(set = 0, binding = 1, r32f) writeonly uniform image2DArray uDestinationTexture; // Destination mipmap level image
#else
layout(set = 0, binding = 0) uniform sampler2D uSourceTexture; // Source mipmap level texture
layout(set = 0, binding = 1, r32f) writeonly uniform image2D uDestinationTexture; // Destination mipmap level image
#endif

/* clang-format on */

void main() {
#ifdef MULTIVIEW
  ivec3 invocationPosition = ivec3(gl_GlobalInvocationID.xyz);
  ivec2 xy = invocationPosition.xy;
  ivec3 destinationTextureSize = imageSize(uDestinationTexture);
  if (all(greaterThanEqual(invocationPosition, ivec3(0))) && all(lessThan(invocationPosition, destinationTextureSize)))
#else
  ivec2 invocationPosition = ivec2(gl_GlobalInvocationID.xy);
  ivec2 xy = invocationPosition.xy;
  ivec2 destinationTextureSize = imageSize(uDestinationTexture);
  if (all(greaterThanEqual(invocationPosition, ivec2(0))) && all(lessThan(invocationPosition, destinationTextureSize)))
#endif
  {
#ifdef MULTIVIEW
    int viewIndex = int(gl_GlobalInvocationID.z);
    ivec3 sourceSize = ivec3(textureSize(uSourceTexture, 0).xyz);
    ivec3 sourceSizeMask = sourceSize - ivec3(1);
    float depth;
  #if MIPMAPLEVEL == 0
     depth = texture(uSourceTexture, vec3((vec2(xy) + vec2(0.5)) / vec2(sourceSize.xy), float(viewIndex)), 0.0).x;
  #else
      ivec3 sourceXY = ivec3(xy.xy << ivec2(1), viewIndex);
    #if 1  
      vec4 depths = textureGather(uSourceTexture, vec3(vec2(vec2(sourceXY) + vec2(0.5)) / vec2(sourceSize.xy), sourceXY.z), 0);
      #ifdef REVERSEDZ
        depth = min(min(depths.x, depths.y), min(depths.z, depths.w));
      #else
        depth = max(max(depths.x, depths.y), max(depths.z, depths.w));
      #endif
    #else
      #ifdef REVERSEDZ
          depth = min(min(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 0, 0), ivec3(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 0, 0), ivec3(0), sourceSizeMask), 0).x),   //
                      min(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 1, 0), ivec3(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 1, 0), ivec3(0), sourceSizeMask), 0).x));  //
      #else
          depth = max(max(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 0, 0), ivec3(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 0, 0), ivec3(0), sourceSizeMask), 0).x),   //
                      max(texelFetch(uSourceTexture, clamp(sourceXY + ivec3(1, 1, 0), ivec3(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec3(0, 1, 0), ivec3(0), sourceSizeMask), 0).x));  //
      #endif
    #endif
  #endif
#else
    ivec2 sourceSize = ivec2(textureSize(uSourceTexture, 0).xy);
    ivec2 sourceSizeMask = sourceSize - ivec2(1);
    float depth;
  #if MIPMAPLEVEL == 0
     depth = texture(uSourceTexture, (vec2(xy) + vec2(0.5)) / vec2(sourceSize.xy), 0.0).x;
  #else
      ivec2 sourceXY = xy << ivec2(1);
    #if 1  
      vec4 depths = textureGather(uSourceTexture, vec2(vec2(sourceXY) + vec2(0.5)) / vec2(sourceSize.xy), 0);
      #ifdef REVERSEDZ
        depth = min(min(depths.x, depths.y), min(depths.z, depths.w));
      #else
        depth = max(max(depths.x, depths.y), max(depths.z, depths.w));
      #endif
    #else
      #ifdef REVERSEDZ
          depth = min(min(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 0), ivec2(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 0), ivec2(0), sourceSizeMask), 0).x),   //
                      min(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 1), ivec2(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 1), ivec2(0), sourceSizeMask), 0).x));  //
      #else
          depth = max(max(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 0), ivec2(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 0), ivec2(0), sourceSizeMask), 0).x),   //
                      max(texelFetch(uSourceTexture, clamp(sourceXY + ivec2(1, 1), ivec2(0), sourceSizeMask), 0).x,    //
                          texelFetch(uSourceTexture, clamp(sourceXY + ivec2(0, 1), ivec2(0), sourceSizeMask), 0).x));  //
      #endif
    #endif
  #endif
#endif
    imageStore(uDestinationTexture, invocationPosition, vec4(depth));
  }
}

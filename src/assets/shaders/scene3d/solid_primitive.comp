#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_samplerless_texture_functions : enable

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define PRIMITIVE_TOPOLOGY_POINT 0u
#define PRIMITIVE_TOPOLOGY_LINE 1u
#define PRIMITIVE_TOPOLOGY_TRIANGLE 2u
#define PRIMITIVE_TOPOLOGY_TRIANGLE_WIREFRAME 3u

struct Vertex {
  uvec4 position; // xy = Clip space position, zw = Offset0
  uvec4 position0; // xyz = Position, w = Primitive topology
  uvec4 position1; // xyz = Position, w = Line thickness or point size
  uvec4 position2; // xyz = Position, w = unused 
  uvec4 offset1Offset2; // xy = Offset1, zw = Offset2
  uvec4 color; // Color
};

#define Primitive Vertex // Just for simplicity so these are the same

layout(set = 0, binding = 0) buffer SourcePrimitives {
  Primitive primitives[];
} sourcePrimitives;

layout(set = 0, binding = 1) buffer DestinationVertices {
  Vertex vertices[];
} destinationVertices;

layout(set = 0, binding = 2) buffer DestinationIndices {
  uint indices[];
} destinationIndices;

/*
// From Vulkan spec, just as reference: 
struct VkDrawIndexedIndirectCommand {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
};
*/

struct DrawIndexedIndirectCommand {
  uvec4 cmd0; // indexCount_instanceCount_firstIndex_vertexOffset; // x = indexCount, y = instanceCount, z = firstIndex, w = vertexOffset  
  uvec4 cmd1; // firstInstance_padding0_padding1_padding2; // x = firstInstance, y = vertexCount, z = unused, w = unused
};

layout(set = 0, binding = 3) coherent buffer DestinationDrawIndexedIndirectCommand {
  DrawIndexedIndirectCommand drawIndexedIndirectCommand;
} destinationDrawIndexedIndirectCommand;

layout(push_constant) uniform PushConstants {
  uint viewBaseIndex;
  uint countViews;
  uint countAllViews;
  uint countPrimitives;
  vec2 viewPortSize;
} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(std140, set = 1, binding = 0) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

/* clang-format on */

vec2 clipSpaceToScreenSpace(const vec2 clipSpace) {
  return fma(clipSpace, vec2(0.5), vec2(0.5)) * pushConstants.viewPortSize;
}

vec2 screenSpaceToClipSpace(const vec2 screenSpace) {
  return fma(screenSpace / pushConstants.viewPortSize, vec2(2.0), vec2(1.0));
}

void main(){

  uint primitiveIndex = gl_GlobalInvocationID.x;

  if(primitiveIndex < pushConstants.countPrimitives){

    uint viewBaseIndex = pushConstants.viewBaseIndex;

    Primitive primitive = sourcePrimitives.primitives[primitiveIndex];
    
    uint primitiveTopology = primitive.position0.w & 3u;
    bool threeDimensional = (primitive.position0.w & 4u) == 0u;

    // Initialize the AABB with infinity and -infinity
    vec4 aabb = vec4(uintBitsToFloat(0x7f800000u), uintBitsToFloat(0x7f800000u), uintBitsToFloat(0xff800000u), uintBitsToFloat(0xff800000u));

    bool visible = true;

    if(threeDimensional){

      switch(primitiveTopology){
        
        case PRIMITIVE_TOPOLOGY_POINT: {

          // Point (or circle)

          // Center of the point (or circle) 
          vec3 center3D = uintBitsToFloat(primitive.position0.xyz);
          vec2 centerOffset = uintBitsToFloat(primitive.position.wz);

          visible = false;

          // Ensure that the point is visible in all views at the correct positions
          for(int viewIndex = 0; viewIndex < int(pushConstants.countViews); viewIndex++){

            mat4 viewProjectionMatrix = uView.views[viewBaseIndex + uint(viewIndex)].projectionMatrix * uView.views[viewBaseIndex + uint(viewIndex)].viewMatrix;

            vec4 centerClip = viewProjectionMatrix * vec4(center3D, 1.0);

            visible = visible || all(greaterThanEqual(centerClip.xyz, vec3(-centerClip.w)));

            vec2 centerScreen = clipSpaceToScreenSpace((centerClip.xy / centerClip.w) + centerOffset);

            aabb.xy = min(aabb.xy, centerScreen);
            aabb.zw = max(aabb.zw, centerScreen);

          } 

          float radius = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the radius for anti-aliasing

          // Add the radius to the AABB
          aabb.xyzw += vec2(-radius, radius).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_LINE: {

          // Line
          
          // Line start
          vec3 lineStart3D = uintBitsToFloat(primitive.position0.xyz);
          vec2 lineStartOffset = uintBitsToFloat(primitive.position.wz);

          // Line end
          vec3 lineEnd3D = uintBitsToFloat(primitive.position1.xyz);
          vec2 lineEndOffset = uintBitsToFloat(primitive.offset1Offset2.xy);

          visible = false;

          // Ensure that the line is visible in all views at the correct positions
          for(int viewIndex = 0; viewIndex < int(pushConstants.countViews); viewIndex++){

            mat4 viewProjectionMatrix = uView.views[viewBaseIndex + uint(viewIndex)].projectionMatrix * uView.views[viewBaseIndex + uint(viewIndex)].viewMatrix;

            vec4 lineStartClip = viewProjectionMatrix * vec4(lineStart3D, 1.0);
            vec4 lineEndClip = viewProjectionMatrix * vec4(lineEnd3D, 1.0);

            visible = visible || (all(greaterThanEqual(lineStartClip.xyz, vec3(-lineStartClip.w))) ||
                                  all(greaterThanEqual(lineEndClip.xyz, vec3(-lineEndClip.w))));

            vec2 lineStartScreen = clipSpaceToScreenSpace((lineStartClip.xy / lineStartClip.w) + lineStartOffset);
            vec2 lineEndScreen = clipSpaceToScreenSpace((lineEndClip.xy / lineEndClip.w) + lineEndOffset);

            aabb.xy = min(aabb.xy, lineStartScreen);
            aabb.zw = max(aabb.zw, lineStartScreen);

            aabb.xy = min(aabb.xy, lineEndScreen);
            aabb.zw = max(aabb.zw, lineEndScreen);

          }

          float lineThickness = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the line tickness for anti-aliasing

          // Add the radius to the AABB
          aabb.xyzw += vec2(-lineThickness, lineThickness).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_TRIANGLE: {

          // Triangle

          // Triangle vertex 0
          vec3 triangleVertex03D = uintBitsToFloat(primitive.position0.xyz);
          vec2 triangleVertex0Offset = uintBitsToFloat(primitive.position.wz);

          // Triangle vertex 1
          vec3 triangleVertex13D = uintBitsToFloat(primitive.position1.xyz);
          vec2 triangleVertex1Offset = uintBitsToFloat(primitive.offset1Offset2.xy);

          // Triangle vertex 2
          vec3 triangleVertex23D = uintBitsToFloat(primitive.position2.xyz);
          vec2 triangleVertex2Offset = uintBitsToFloat(primitive.offset1Offset2.zw);

          visible = false;
          
          // Ensure that the triangle is visible in all views at the correct positions
          for(int viewIndex = 0; viewIndex < int(pushConstants.countViews); viewIndex++){

            mat4 viewProjectionMatrix = uView.views[viewBaseIndex + uint(viewIndex)].projectionMatrix * uView.views[viewBaseIndex + uint(viewIndex)].viewMatrix;

            vec4 triangleVertex0Clip = viewProjectionMatrix * vec4(triangleVertex03D, 1.0);
            vec4 triangleVertex1Clip = viewProjectionMatrix * vec4(triangleVertex13D, 1.0);
            vec4 triangleVertex2Clip = viewProjectionMatrix * vec4(triangleVertex23D, 1.0);

            // Check if the triangle is visible in the current view (not behind the camera)
            visible = visible || (all(greaterThanEqual(triangleVertex0Clip.xyz, vec3(-triangleVertex0Clip.w))) ||
                                  all(greaterThanEqual(triangleVertex1Clip.xyz, vec3(-triangleVertex1Clip.w))) || 
                                  all(greaterThanEqual(triangleVertex2Clip.xyz, vec3(-triangleVertex2Clip.w))));

            vec2 triangleVertex0Screen = clipSpaceToScreenSpace((triangleVertex0Clip.xy / triangleVertex0Clip.w) + triangleVertex0Offset);
            vec2 triangleVertex1Screen = clipSpaceToScreenSpace((triangleVertex1Clip.xy / triangleVertex1Clip.w) + triangleVertex1Offset);
            vec2 triangleVertex2Screen = clipSpaceToScreenSpace((triangleVertex2Clip.xy / triangleVertex2Clip.w) + triangleVertex2Offset);

            aabb.xy = min(aabb.xy, triangleVertex0Screen);
            aabb.zw = max(aabb.zw, triangleVertex0Screen);

            aabb.xy = min(aabb.xy, triangleVertex1Screen);
            aabb.zw = max(aabb.zw, triangleVertex1Screen);

            aabb.xy = min(aabb.xy, triangleVertex2Screen);
            aabb.zw = max(aabb.zw, triangleVertex2Screen);

          }

          // Add the radius to the AABB
          aabb.xyzw += vec2(-1.0, 1.0).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_TRIANGLE_WIREFRAME: {

          // Triangle wireframe

          // Triangle vertex 0
          vec3 triangleVertex03D = uintBitsToFloat(primitive.position0.xyz);
          vec2 triangleVertex0Offset = uintBitsToFloat(primitive.position.wz);

          // Triangle vertex 1
          vec3 triangleVertex13D = uintBitsToFloat(primitive.position1.xyz);
          vec2 triangleVertex1Offset = uintBitsToFloat(primitive.offset1Offset2.xy);

          // Triangle vertex 2
          vec3 triangleVertex23D = uintBitsToFloat(primitive.position2.xyz);
          vec2 triangleVertex2Offset = uintBitsToFloat(primitive.offset1Offset2.zw);

          visible = false;

          // Ensure that the triangle is visible in all views at the correct positions
          for(int viewIndex = 0; viewIndex < int(pushConstants.countViews); viewIndex++){

            mat4 viewProjectionMatrix = uView.views[viewBaseIndex + uint(viewIndex)].projectionMatrix * uView.views[viewBaseIndex + uint(viewIndex)].viewMatrix;

            vec4 triangleVertex0Clip = viewProjectionMatrix * vec4(triangleVertex03D, 1.0);
            vec4 triangleVertex1Clip = viewProjectionMatrix * vec4(triangleVertex13D, 1.0);
            vec4 triangleVertex2Clip = viewProjectionMatrix * vec4(triangleVertex23D, 1.0);

            // Check if the triangle is visible in the current view (not behind the camera)
            visible = visible || (all(greaterThanEqual(triangleVertex0Clip.xyz, vec3(-triangleVertex0Clip.w))) ||
                                  all(greaterThanEqual(triangleVertex1Clip.xyz, vec3(-triangleVertex1Clip.w))) || 
                                  all(greaterThanEqual(triangleVertex2Clip.xyz, vec3(-triangleVertex2Clip.w))));

            vec2 triangleVertex0Screen = clipSpaceToScreenSpace((triangleVertex0Clip.xy / triangleVertex0Clip.w) + triangleVertex0Offset);
            vec2 triangleVertex1Screen = clipSpaceToScreenSpace((triangleVertex1Clip.xy / triangleVertex1Clip.w) + triangleVertex1Offset);
            vec2 triangleVertex2Screen = clipSpaceToScreenSpace((triangleVertex2Clip.xy / triangleVertex2Clip.w) + triangleVertex2Offset);

            aabb.xy = min(aabb.xy, triangleVertex0Screen);
            aabb.zw = max(aabb.zw, triangleVertex0Screen);

            aabb.xy = min(aabb.xy, triangleVertex1Screen);
            aabb.zw = max(aabb.zw, triangleVertex1Screen);

            aabb.xy = min(aabb.xy, triangleVertex2Screen);
            aabb.zw = max(aabb.zw, triangleVertex2Screen);

          }

          float lineThickness = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the line tickness for anti-aliasing

          // Add the line thickness to the AABB
          aabb.xyzw += vec2(-lineThickness, lineThickness).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        default:{
          // Do nothing
          break;
        }

      }

    }else{

      switch(primitiveTopology){
        
        case PRIMITIVE_TOPOLOGY_POINT: {

          // Point (or circle)

          // Center of the point (or circle) 
          vec2 center2D = uintBitsToFloat(primitive.position0.xy);
          vec2 centerOffset = uintBitsToFloat(primitive.position.wz);
          vec2 centerScreen = clipSpaceToScreenSpace(center2D.xy + centerOffset);
          aabb.xy = min(aabb.xy, centerScreen);
          aabb.zw = max(aabb.zw, centerScreen);

          float radius = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the radius for anti-aliasing

          // Add the radius to the AABB
          aabb.xyzw += vec2(-radius, radius).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_LINE: {

          // Line
          
          // Line start
          vec2 lineStart2D = uintBitsToFloat(primitive.position0.xy);
          vec2 lineStartOffset = uintBitsToFloat(primitive.position.wz);

          // Line end
          vec2 lineEnd2D = uintBitsToFloat(primitive.position1.xy);
          vec2 lineEndOffset = uintBitsToFloat(primitive.offset1Offset2.xy);

          vec2 lineStartScreen = clipSpaceToScreenSpace(lineStart2D + lineStartOffset);
          vec2 lineEndScreen = clipSpaceToScreenSpace(lineEnd2D + lineEndOffset);

          aabb.xy = min(aabb.xy, lineStartScreen);
          aabb.zw = max(aabb.zw, lineStartScreen);

          aabb.xy = min(aabb.xy, lineEndScreen);
          aabb.zw = max(aabb.zw, lineEndScreen);

          float lineThickness = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the line tickness for anti-aliasing

          // Add the radius to the AABB
          aabb.xyzw += vec2(-lineThickness, lineThickness).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_TRIANGLE: {

          // Triangle

          // Triangle vertex 0
          vec2 triangleVertex02D = uintBitsToFloat(primitive.position0.xy);
          vec2 triangleVertex0Offset = uintBitsToFloat(primitive.position.wz);

          // Triangle vertex 1
          vec2 triangleVertex12D = uintBitsToFloat(primitive.position1.xy);
          vec2 triangleVertex1Offset = uintBitsToFloat(primitive.offset1Offset2.xy);

          // Triangle vertex 2
          vec2 triangleVertex22D = uintBitsToFloat(primitive.position2.xy);
          vec2 triangleVertex2Offset = uintBitsToFloat(primitive.offset1Offset2.zw);

          vec2 triangleVertex0Screen = clipSpaceToScreenSpace(triangleVertex02D.xy + triangleVertex0Offset);
          vec2 triangleVertex1Screen = clipSpaceToScreenSpace(triangleVertex12D.xy + triangleVertex1Offset);
          vec2 triangleVertex2Screen = clipSpaceToScreenSpace(triangleVertex22D.xy + triangleVertex2Offset);

          aabb.xy = min(aabb.xy, triangleVertex0Screen);
          aabb.zw = max(aabb.zw, triangleVertex0Screen);

          aabb.xy = min(aabb.xy, triangleVertex1Screen);
          aabb.zw = max(aabb.zw, triangleVertex1Screen);

          aabb.xy = min(aabb.xy, triangleVertex2Screen);
          aabb.zw = max(aabb.zw, triangleVertex2Screen);

          // Add the radius to the AABB
          aabb.xyzw += vec2(-1.0, 1.0).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        case PRIMITIVE_TOPOLOGY_TRIANGLE_WIREFRAME: {

          // Triangle wireframe

          // Triangle vertex 0
          vec2 triangleVertex02D = uintBitsToFloat(primitive.position0.xy);
          vec2 triangleVertex0Offset = uintBitsToFloat(primitive.position.wz);

          // Triangle vertex 1
          vec2 triangleVertex12D = uintBitsToFloat(primitive.position1.xy);
          vec2 triangleVertex1Offset = uintBitsToFloat(primitive.offset1Offset2.xy);

          // Triangle vertex 2
          vec2 triangleVertex22D = uintBitsToFloat(primitive.position2.xy);
          vec2 triangleVertex2Offset = uintBitsToFloat(primitive.offset1Offset2.zw);

          vec2 triangleVertex0Screen = clipSpaceToScreenSpace(triangleVertex02D.xy + triangleVertex0Offset);
          vec2 triangleVertex1Screen = clipSpaceToScreenSpace(triangleVertex12D.xy + triangleVertex1Offset);
          vec2 triangleVertex2Screen = clipSpaceToScreenSpace(triangleVertex22D.xy + triangleVertex2Offset);

          aabb.xy = min(aabb.xy, triangleVertex0Screen);
          aabb.zw = max(aabb.zw, triangleVertex0Screen);

          aabb.xy = min(aabb.xy, triangleVertex1Screen);
          aabb.zw = max(aabb.zw, triangleVertex1Screen);

          aabb.xy = min(aabb.xy, triangleVertex2Screen);
          aabb.zw = max(aabb.zw, triangleVertex2Screen);

          float lineThickness = uintBitsToFloat(primitive.position1.w) + 1.0; // Add 1.0 to the line tickness for anti-aliasing

          // Add the line thickness to the AABB
          aabb.xyzw += vec2(-lineThickness, lineThickness).xxyy;

          aabb.xy = screenSpaceToClipSpace(aabb.xy);
          aabb.zw = screenSpaceToClipSpace(aabb.zw);

          break;

        }

        default:{
          // Do nothing
          break;
        }

      }

    }    

    // Check if the primitive is visible at all (culling)
    visible = visible && (all(lessThanEqual(aabb.xy, vec2(1.0))) && all(greaterThanEqual(aabb.zw, vec2(0.0))) && all(lessThanEqual(aabb.xy, aabb.zw)));

    // If the primitive is visible, generate the vertices and indices
    uint firstVertex = 0u;
    if(visible){

      // Generate the quad vertices for the current primitive 
      firstVertex = atomicAdd(destinationDrawIndexedIndirectCommand.drawIndexedIndirectCommand.cmd1.y, 4u); // Each primitive has 4 vertices for a quad of two triangles
      {

        destinationVertices.vertices[firstVertex] = Vertex(
          uvec4(floatBitsToUint(aabb.xy), primitive.position.wz),
          primitive.position0,
          primitive.position1,
          primitive.position2,
          primitive.offset1Offset2,
          primitive.color
        );

        destinationVertices.vertices[firstVertex + 1u] = Vertex(
          uvec4(floatBitsToUint(aabb.zy), primitive.position.wz),
          primitive.position0,
          primitive.position1,
          primitive.position2,
          primitive.offset1Offset2,
          primitive.color
        );

        destinationVertices.vertices[firstVertex + 2u] = Vertex(
          uvec4(floatBitsToUint(aabb.zx), primitive.position.wz),
          primitive.position0,
          primitive.position1,
          primitive.position2,
          primitive.offset1Offset2,
          primitive.color
        );

        destinationVertices.vertices[firstVertex + 3u] = Vertex(
          uvec4(floatBitsToUint(aabb.xz), primitive.position.wz),
          primitive.position0,
          primitive.position1,
          primitive.position2,
          primitive.offset1Offset2,
          primitive.color
        );

      }  

    }

    {  

      // Generate the quad indices for the current primitive
//    uint firstIndex = atomicAdd(destinationDrawIndexedIndirectCommand.drawIndexedIndirectCommand.cmd0.x, 6u); // Each primitive has 6 indices for a quad of two triangles
      // We can't use atomicAdd here because the indices need to be in order to ensure that the rendering order is correct for the primitives,
      // so we generate degenerate indices for invisible primitives to keep the indices in sync with the vertices but not render the primitive.      
      uint firstIndex = primitiveIndex * 6u; // Each primitive has 6 indices for a quad of two triangles
      if(visible){

        destinationIndices.indices[firstIndex] = firstVertex;
        destinationIndices.indices[firstIndex + 1u] = firstVertex + 1u;
        destinationIndices.indices[firstIndex + 2u] = firstVertex + 2u;

        destinationIndices.indices[firstIndex + 3u] = firstVertex;
        destinationIndices.indices[firstIndex + 4u] = firstVertex + 2u;
        destinationIndices.indices[firstIndex + 5u] = firstVertex + 3u;

      }else{

        // If the primitive is not visible, output degenerate indices to keep the indices in sync with the vertices but not render the primitive

        destinationIndices.indices[firstIndex] = firstVertex;
        destinationIndices.indices[firstIndex + 1u] = firstVertex;
        destinationIndices.indices[firstIndex + 2u] = firstVertex;

        destinationIndices.indices[firstIndex + 3u] = firstVertex;
        destinationIndices.indices[firstIndex + 4u] = firstVertex;
        destinationIndices.indices[firstIndex + 5u] = firstVertex;

      }

    }

    // All further things happen in the vertex and fragment shaders

  }

}
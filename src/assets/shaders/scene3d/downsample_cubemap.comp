#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// texture2D instead of image2D, because texture2D doesn't need a format specifier and can be used with any format, while read-accessable
// image2D requires a format specifier and can only be used with the specified format. This is a workaround for the lack of support for 
// the RGBA9E5 format in image2D. And texture2D doesn't need like image2D no sampler attached, so it's more or less the same as image2D 
// at the usage, at least here in this case. 
layout(set = 0, binding = 0) uniform texture2D uSourceTexture;

#ifdef USE_RGB9E5
layout(set = 0, binding = 1, r32ui) writeonly uniform uimage2D uDestinationTextures[];
#else
layout(set = 0, binding = 1) writeonly uniform image2D uDestinationTextures[];
#endif

layout(push_constant) uniform PushConstants {
  int countMipMapLevels;
} pushConstants;

shared float sharedR[8 * 8];
shared float sharedG[8 * 8];
shared float sharedB[8 * 8];
#ifndef USE_RGB9E5
shared float sharedA[8 * 8]; // ignored for RGB9E5, as the alpha channel is not used at that format
#endif

/* clang-format on */

#ifdef USE_RGB9E5
#include "rgb9e5.glsl"
#endif

vec4 reduceOp(const in vec4 a, const in vec4 b){
  return mix(a, b, 0.5);
}

void main() {

  // Maximum four mipmap levels in a single pass, so more mip map levels require multiple passes divided by four mip maps, the remainder must be in
  // pushConstants.countMipMapLevels.

  ivec2 invocationPosition = ivec2(gl_GlobalInvocationID.xy);
              
  ivec2 sourceSize = textureSize(uSourceTexture, 0);

  ivec2 destinationTextureSize = imageSize(uDestinationTextures[0]).xy;

  vec4 texel;

  if(all(lessThan(invocationPosition.xy, sourceSize))){
    mat4x4 texels = mat4x4(
      texelFetch(uSourceTexture, (invocationPosition.xy << 1) + ivec2(0, 0), 0),
      texelFetch(uSourceTexture, (invocationPosition.xy << 1) + ivec2(1, 0), 0),
      texelFetch(uSourceTexture, (invocationPosition.xy << 1) + ivec2(0, 1), 0),
      texelFetch(uSourceTexture, (invocationPosition.xy << 1) + ivec2(1, 1), 0)
    );
    texel = normalize(reduceOp(reduceOp(texels[0], texels[1]), reduceOp(texels[2], texels[3])));
  }else{
    texel = vec4(0.0);
  } 

  if(all(lessThan(invocationPosition.xy >> 0, destinationTextureSize))){
#ifdef USE_RGB9E5
    imageStore(uDestinationTextures[0], invocationPosition.xy >> 0, uvec4(encodeRGB9E5(texel.xyz)));
#else    
    imageStore(uDestinationTextures[0], invocationPosition.xy >> 0, vec4(texel));
#endif
  }
  if(pushConstants.countMipMapLevels == 1){
    return;
  }

  int localInvocationIndex = int(gl_LocalInvocationIndex);

  sharedR[localInvocationIndex] = texel.x;
  sharedG[localInvocationIndex] = texel.y;
  sharedB[localInvocationIndex] = texel.z;
#ifndef USE_RGB9E5
  sharedA[localInvocationIndex] = texel.w;
#endif

  barrier();

  destinationTextureSize = max(ivec2(1), destinationTextureSize >> 1);
  
  if((localInvocationIndex & 0x09 /*0b001001*/) == 0){
    texel = normalize(
      reduceOp(
        reduceOp(
          texel, 
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x01], sharedG[localInvocationIndex + 0x01], sharedB[localInvocationIndex + 0x01], 1.0)
#else          
          vec4(sharedR[localInvocationIndex + 0x01], sharedG[localInvocationIndex + 0x01], sharedB[localInvocationIndex + 0x01], sharedA[localInvocationIndex + 0x01])
#endif
        ), 
        reduceOp(
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x08], sharedG[localInvocationIndex + 0x08], sharedB[localInvocationIndex + 0x08], 1.0),
          vec4(sharedR[localInvocationIndex + 0x09], sharedG[localInvocationIndex + 0x09], sharedB[localInvocationIndex + 0x09], 1.0)
#else
          vec4(sharedR[localInvocationIndex + 0x08], sharedG[localInvocationIndex + 0x08], sharedB[localInvocationIndex + 0x08], sharedA[localInvocationIndex + 0x08]),
          vec4(sharedR[localInvocationIndex + 0x09], sharedG[localInvocationIndex + 0x09], sharedB[localInvocationIndex + 0x09], sharedA[localInvocationIndex + 0x09])
#endif          
        )
      )
    );
    if(all(lessThan(invocationPosition.xy >> 1, destinationTextureSize))){
#ifdef USE_RGB9E5
      imageStore(uDestinationTextures[1], invocationPosition.xy >> 1, uvec4(encodeRGB9E5(texel.xyz)));
#else
      imageStore(uDestinationTextures[1], invocationPosition.xy >> 1, vec4(texel));
#endif      
    }
    sharedR[localInvocationIndex] = texel.x;
    sharedG[localInvocationIndex] = texel.y;
    sharedB[localInvocationIndex] = texel.z;
#ifndef USE_RGB9E5
    sharedA[localInvocationIndex] = texel.w;
#endif
  }
  if(pushConstants.countMipMapLevels == 2){
    return;
  }
  barrier();

  destinationTextureSize = max(ivec2(1), destinationTextureSize >> 1);

  if((localInvocationIndex & 0x1b /*0b011011*/) == 0){
    texel = normalize(
      reduceOp(
        reduceOp(
          texel, 
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x02], sharedG[localInvocationIndex + 0x02], sharedB[localInvocationIndex + 0x02], 1.0)
#else
          vec4(sharedR[localInvocationIndex + 0x02], sharedG[localInvocationIndex + 0x02], sharedB[localInvocationIndex + 0x02], sharedA[localInvocationIndex + 0x02])
#endif          
        ), 
        reduceOp(
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x10], sharedG[localInvocationIndex + 0x10], sharedB[localInvocationIndex + 0x10], 1.0),  
          vec4(sharedR[localInvocationIndex + 0x12], sharedG[localInvocationIndex + 0x12], sharedB[localInvocationIndex + 0x12], 1.0)
#else
          vec4(sharedR[localInvocationIndex + 0x10], sharedG[localInvocationIndex + 0x10], sharedB[localInvocationIndex + 0x10], sharedA[localInvocationIndex + 0x10]), 
          vec4(sharedR[localInvocationIndex + 0x12], sharedG[localInvocationIndex + 0x12], sharedB[localInvocationIndex + 0x12], sharedA[localInvocationIndex + 0x12])
#endif          
        )
      )
    );
    if(all(lessThan(invocationPosition.xy >> 2, destinationTextureSize))){
#ifdef USE_RGB9E5
      imageStore(uDestinationTextures[2], invocationPosition.xy >> 2, uvec4(encodeRGB9E5(texel.xyz)));
#else
      imageStore(uDestinationTextures[2], invocationPosition.xy >> 2, vec4(texel)); 
#endif
    }
    sharedR[localInvocationIndex] = texel.x;
    sharedG[localInvocationIndex] = texel.y;
    sharedB[localInvocationIndex] = texel.z;
#ifndef USE_RGB9E5
    sharedA[localInvocationIndex] = texel.w;
#endif    
  }
  if(pushConstants.countMipMapLevels == 3){
    return;
  }
  barrier();

  destinationTextureSize = max(ivec2(1), destinationTextureSize >> 1);

  if((localInvocationIndex & 0x3f /*0b111111*/) == 0){
    texel = normalize(
      reduceOp(
        reduceOp(
          texel, 
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x04], sharedG[localInvocationIndex + 0x04], sharedB[localInvocationIndex + 0x04], 1.0)
#else
          vec4(sharedR[localInvocationIndex + 0x04], sharedG[localInvocationIndex + 0x04], sharedB[localInvocationIndex + 0x04], sharedA[localInvocationIndex + 0x04])  
#endif          
        ), 
        reduceOp(
#ifdef USE_RGB9E5
          vec4(sharedR[localInvocationIndex + 0x20], sharedG[localInvocationIndex + 0x20], sharedB[localInvocationIndex + 0x20], 1.0),
          vec4(sharedR[localInvocationIndex + 0x24], sharedG[localInvocationIndex + 0x24], sharedB[localInvocationIndex + 0x24], 1.0)
#else
          vec4(sharedR[localInvocationIndex + 0x20], sharedG[localInvocationIndex + 0x20], sharedB[localInvocationIndex + 0x20], sharedA[localInvocationIndex + 0x20]),
          vec4(sharedR[localInvocationIndex + 0x24], sharedG[localInvocationIndex + 0x24], sharedB[localInvocationIndex + 0x24], sharedA[localInvocationIndex + 0x24])
#endif          
        )
      )
    );
    if(all(lessThan(invocationPosition.xy >> 3, destinationTextureSize))){
#ifdef USE_RGB9E5
      imageStore(uDestinationTextures[3], invocationPosition.xy >> 3, uvec4(encodeRGB9E5(texel.xyz)));
#else
      imageStore(uDestinationTextures[3], invocationPosition.xy >> 3, vec4(texel));
#endif
    }
  }

}
#version 460

#if defined(VERTEX_SHADER_CODE_PATH)
  // When the vertex shader code path is defined, then this shader is compiled as a vertex shader, where
  // the compute shader code generates payload data for the vertex shader invocations as poor-man mesh 
  // shader alternative into storage buffers, but with size limitations.  
  #pragma shader_stage(vertex)
#else
  #pragma shader_stage(mesh)
  #extension GL_EXT_mesh_shader : enable 
#endif

#extension GL_EXT_multiview : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_control_flow_attributes : enable
#ifdef WIREFRAME
  #extension GL_EXT_fragment_shader_barycentric : enable
  #define HAVE_PERVERTEX
#endif

#define GROUP_SIZE 128
#define GRASS_VERT_COUNT 256
#define GRASS_PRIM_COUNT 192

#if !defined(VERTEX_SHADER_CODE_PATH)
layout(local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(triangles, max_vertices = GRASS_VERT_COUNT, max_primitives = GRASS_PRIM_COUNT) out;
#endif

layout(push_constant) uniform PushConstants {

  mat4 modelMatrix;

  uint baseViewIndex;
  uint countViews;
  uint additionalViewIndex;
  uint countAdditionalViews; 

  uint tileMapResolution;
  uint tileResolution;  
  uint maximumCountVertices;
  uint maximumCountIndices;
 
  float maximumDistance;
  float grassHeight;
  float grassThickness;
  uint countVerticesPerBladeEdge;

  float time;
  vec2 jitter; 

} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256 views as maximum for a single renderer instance (but a application/game can have multiple renderer instances for the same scene)  
} uView;

struct TaskData {
  mat3 bladeTangentSpaceBasis;
  vec3 bladePosition;
  uint bladeIndex;
  float height;
};

#if defined(VERTEX_SHADER_CODE_PATH)
layout(set = 1, binding = 2, std430) buffer TaskPayloadMetaData {
  uint countPayloads;
  uint countVertices;
} taskPayloadMetaData;

layout(set = 1, binding = 3, std430) buffer TaskPayload {
  TaskData taskData[];
} taskPayload;
#else
taskPayloadSharedEXT TaskData taskData;
#endif

#if defined(VERTEX_SHADER_CODE_PATH)
#if defined(RAYTRACING)

layout(location = 0) out vec3 outWorldSpacePosition;

layout(location = 1) out OutBlock {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec3 worldSpacePosition;
  vec3 viewSpacePosition;
  vec3 cameraRelativePosition;
  vec2 jitter;
#ifdef VELOCITY
  vec4 previousClipSpace;
  vec4 currentClipSpace;
#endif  
} outBlock;

#else

layout(location = 0) out OutBlock {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec3 worldSpacePosition;
  vec3 viewSpacePosition;
  vec3 cameraRelativePosition;
  vec2 jitter;
#ifdef VELOCITY
  vec4 previousClipSpace;
  vec4 currentClipSpace;
#endif  
} outBlock;
#endif // defined(RAYTRACING)
#else
#if defined(RAYTRACING)

layout(location = 0) out vec3 outWorldSpacePosition[];

layout(location = 1) out OutBlock {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec3 worldSpacePosition;
  vec3 viewSpacePosition;
  vec3 cameraRelativePosition;
  vec2 jitter;
#ifdef VELOCITY
  vec4 previousClipSpace;
  vec4 currentClipSpace;
#endif  
} outBlock[];

#else

layout(location = 0) out OutBlock {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec3 worldSpacePosition;
  vec3 viewSpacePosition;
  vec3 cameraRelativePosition;
  vec2 jitter;
#ifdef VELOCITY
  vec4 previousClipSpace;
  vec4 currentClipSpace;
#endif  
} outBlock[];
#endif // defined(RAYTRACING)

#endif // defined(VERTEX_SHADER_CODE_PATH)

#include "pcg.glsl"

vec3 bezier(const in vec3 p0, const in vec3 p1, const in vec3 p2, const in float t){
  return mix(mix(p0, p1, t), mix(p1, p2, t), t);
}

vec3 bezierDerivative(const in vec3 p0, const in vec3 p1, const in vec3 p2, const in float t){
  return ((2.0 * (1. - t)) * (p1 - p0)) + ((2.0 * t) * (p2 - p1));
}

uint viewIndex = pushConstants.baseViewIndex + uint(gl_ViewIndex);
mat4 viewMatrix = uView.views[viewIndex].viewMatrix;
mat4 projectionMatrix = uView.views[viewIndex].projectionMatrix;
mat4 inverseViewMatrix = uView.views[viewIndex].inverseViewMatrix;

void main() {
  
  const uint countVerticesPerBladeEdge = pushConstants.countVerticesPerBladeEdge;
  const uint countVerticesPerBlade = countVerticesPerBladeEdge * 2u;
  const uint countTrianglesPerBlade = (countVerticesPerBladeEdge * 2u) - 2u; 
  const uint countIndicesPerBlade = countTrianglesPerBlade * 3u;
  const uint countBlades = 1u;

  ////////////////////////////////////////////////////////////////////////////////

  const uint countVertices = countVerticesPerBlade * countBlades;
  const uint countTriangles = countTrianglesPerBlade * countBlades;

  ////////////////////////////////////////////////////////////////////////////////
      
#if defined(VERTEX_SHADER_CODE_PATH)

  // The vertex shader code path is slower than the mesh shader code path, because the vertex shader has to process 
  // all vertices of the grass blades multiple times, but the mesh shader processes each vertex only once, since
  // the mesh shader can deduplicate the vertices of the grass blades index-wise, but the vertex shader can't do that
  // on-the-fly. 

  const uint vertexIndex = gl_VertexIndex;
  const uint triangleIndex = vertexIndex / 3u;
  const uint triangleVertexIndex = vertexIndex - (triangleIndex * 3u);
  const uint quadIndex = triangleIndex >> 1u;
  const uint taskIndex = triangleIndex / (countTrianglesPerBlade * countBlades);
  
  // Map triangle vertex index to the vertex index of the grass blade
  const uint vertexID = 
    ((((triangleIndex & 1u) == 0u) 
      ? (uvec3(0, 1, 2)[triangleVertexIndex]) 
      : (uvec3(3, 2, 1)[triangleVertexIndex])) + 
     (quadIndex << 1u)
    ) % (countVerticesPerBlade * countBlades);

  if(vertexID >= countVertices){
    gl_Position = vec4(uintBitsToFloat(0x7fc00000u)); // NaN for discarded vertices, not optimal, but it should work
    return;
  }

#else

  SetMeshOutputsEXT(countVerticesPerBlade * countBlades, countTrianglesPerBlade * countBlades);

#endif

  ////////////////////////////////////////////////////////////////////////////////

  mat3 planetNormalMatrix = transpose(inverse(mat3(pushConstants.modelMatrix)));

  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;

#if 1
  // The actual standard approach
  vec3 cameraPosition = inverseViewMatrix[3].xyz;
#else
  // This approach assumes that the view matrix has no scaling or skewing, but only rotation and translation.
  vec3 cameraPosition = (-viewMatrix[3].xyz) * mat3(viewMatrix);
#endif   

  ////////////////////////////////////////////////////////////////////////////////

#if defined(VERTEX_SHADER_CODE_PATH)
  {

    const TaskData taskData = taskPayload.taskData[taskIndex];

#else
  for(uint i = 0u; i < 2; i++){

    uint vertexID = gl_LocalInvocationIndex + (i * GROUP_SIZE);
    
    if(vertexID >= countVertices){
      break;
    }
#endif

    uint bladeID = vertexID / countVerticesPerBlade;
    uint vertexIndex = vertexID - (bladeID * countVerticesPerBlade);

    const float grassHeight = taskData.height;
    const float grassThickness = pushConstants.grassThickness;
    const float grassLeaning = 0.03; // TODO: Make it configurable

    // Generate some random data for the grass blade to make it look more natural, but keep it deterministic, based on the global position
    // and the linear global index of the grass blade
    const uvec4 randomUIntData = pcgHash44(uvec4(taskData.bladeIndex, bladeID, 0u, 0u));

    // The following line generates a random float value in the range of [0.0, 1.0] for each component through bittwiddling tricks 
    const vec4 randomFloatData = uintBitsToFloat(((randomUIntData >> uvec4(9u)) & uvec4(0x007fffffu)) | uvec4(0x3f800000u)) - vec4(1.0);

    float bladeDirectionAngle = randomFloatData.y * 6.28318530718; // 2 * PI
    vec2 bladeDirection = normalize(sin(vec2(bladeDirectionAngle) + vec2(1.57079632679, 0.0)));

    float offsetAngle = randomFloatData.z * 6.28318530718; // 2 * PI
    vec2 offsetDirection = normalize(sin(vec2(offsetAngle) + vec2(1.57079632679, 0.0)));      
    float offsetRadius = randomFloatData.x * 0.25; // TODO: Make it configurable

    vec3 bladeOffset = vec3(offsetDirection.xy, 0.0) * offsetRadius; 

    vec3 p0 = bladeOffset;
    vec3 p1 = p0 + vec2(0.0, grassHeight).xxy;
    vec3 p2 = fma(vec3(bladeDirection, 0.0), vec3(grassHeight * grassLeaning), p1);      

    // Add some wind effect to the grass blade 
    {

      const float windDirection = radians(20.0); // TODO: Calculate this based on the global position in 3D space and make it configurable

      const float windStrength = 0.01; // TODO: Calculate this based on the global position in 3D space and make it configurable

      vec2 windOffset = sin(
        vec2(
          pushConstants.time + 
          //dot(sin(vec2(windDirection) + vec2(1.57079632679, 0.0)), vec2(globalXY) / vec2(pushConstants.tileMapResolution * pushConstants.tileResolution)) + 
          (randomFloatData.w * 4.0)
        ) * vec2(0.5, 1.0)
      ) * vec2(2.0, 1.0) * windStrength;

      // TODO: Add additional usage of a velocity field for physical interaction with sphere colliders just as the player

      p2 += vec3(windOffset, 0.0);

    }
    
    // Ensure that the grass blade has a persistent length
    {
      vec3 p01 = p1 - p0;
      vec3 p12 = p2 - p1;
      float L = fma(2.0, length(p2 - p0), length(p01) + length(p12)) / 3.0; 
      float lDiff = grassHeight / L;
      p1 = fma(p01, vec3(lDiff), p0); 
      p2 = fma(p12, vec3(lDiff), p1);
    }

    vec3 sideVector = normalize(vec3(bladeDirection.y, -bladeDirection.x, 0.0)); 

    vec3 offset = sideVector * grassThickness;

    const vec3 patchPosition = taskData.bladePosition;
    const mat3 patchTangentSpaceBasis = taskData.bladeTangentSpaceBasis;

    float t = float(uint(vertexIndex >> 1u)) / float(countVerticesPerBladeEdge - 1u);
    float s = float(int(1 - ((int(vertexIndex) & 1) << 1))); // 1 or -1
    vec3 localP0 = p0 + (offset * (s * 1.0));
    vec3 localP1 = p1 + (offset * (s * 0.7));
    vec3 localP2 = p2 + (offset * (s * 0.3));    
    vec3 position = (pushConstants.modelMatrix * vec4(patchPosition + (patchTangentSpaceBasis * bezier(localP0, localP1, localP2, t)), 1.0)).xyz;
    vec3 normal = normalize(planetNormalMatrix * (patchTangentSpaceBasis * cross(sideVector, normalize(bezierDerivative(localP0, localP1, localP2, t)))));

    vec3 worldSpacePosition = position;

    vec4 viewSpacePosition = viewMatrix * vec4(position, 1.0);
    viewSpacePosition.xyz /= viewSpacePosition.w;

#if defined(VERTEX_SHADER_CODE_PATH)

    outBlock.position = position;         
    outBlock.normal = normalize(transpose(inverse(mat3(pushConstants.modelMatrix))) * normal);
    outBlock.texCoord = vec2(float(uint(vertexIndex & 1u)), t);
    outBlock.worldSpacePosition = worldSpacePosition;
    outBlock.viewSpacePosition = viewSpacePosition.xyz;  
    outBlock.cameraRelativePosition = worldSpacePosition - cameraPosition;
    outBlock.jitter = pushConstants.jitter;
  #ifdef VELOCITY
    outBlock.currentClipSpace = (projectionMatrix * viewMatrix) * vec4(position, 1.0);
    outBlock.previousClipSpace = (uView.views[viewIndex + pushConstants.countAllViews].projectionMatrix * uView.views[viewIndex + pushConstants.countAllViews].viewMatrix) * vec4(position, 1.0);
  #endif

  #if defined(RAYTRACING)
    outWorldSpacePosition = worldSpacePosition;
  #endif
    
    gl_Position = viewProjectionMatrix * vec4(position, 1.0);
    
#else

    outBlock[i].position = position;         
    outBlock[i].normal = normalize(transpose(inverse(mat3(pushConstants.modelMatrix))) * normal);
    outBlock[i].texCoord = vec2(float(uint(i & 1u)), t);
    outBlock[i].worldSpacePosition = worldSpacePosition;
    outBlock[i].viewSpacePosition = viewSpacePosition.xyz;  
    outBlock[i].cameraRelativePosition = worldSpacePosition - cameraPosition;
    outBlock[i].jitter = pushConstants.jitter;
  #ifdef VELOCITY
    outBlock[i].currentClipSpace = (projectionMatrix * viewMatrix) * vec4(position, 1.0);
    outBlock[i].previousClipSpace = (uView.views[viewIndex + pushConstants.countAllViews].projectionMatrix * uView.views[viewIndex + pushConstants.countAllViews].viewMatrix) * vec4(position, 1.0);
  #endif

  #if defined(RAYTRACING)
    outWorldSpacePosition[i] = worldSpacePosition;
  #endif

    gl_MeshVerticesEXT[i].gl_Position = viewProjectionMatrix * vec4(position, 1.0);

#endif

  }

#if !defined(VERTEX_SHADER_CODE_PATH)
  // Emit the indices for the grass blade
  for(uint i = 0u; i < 2u; i++){
    
    uint triangleID = gl_LocalInvocationIndex + (i * GROUP_SIZE);

    if(triangleID >= countTriangles){
      break;
    }

    uint bladeID = triangleID / countTrianglesPerBlade;
    uint triangleIndex = triangleID - (bladeID * countTrianglesPerBlade);

    uint offset = (bladeID * countVerticesPerBlade) + ((triangleIndex >> 1u) << 1u);

    gl_PrimitiveTriangleIndicesEXT[i] = (((triangleIndex & 1u) == 0u) ? uvec3(0, 1, 2) : uvec3(3, 2, 1)) + uvec3(offset);

  }
#endif

} 
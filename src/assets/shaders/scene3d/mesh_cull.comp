#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  uint baseDrawIndexedIndirectCommandIndex;
  uint countDrawIndexedIndirectCommands;
  uint drawCallIndex;
  uint baseViewIndex;
  uint countViews;
} pushConstants;

/*
struct VkDrawIndexedIndirectCommand {
	uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
  uint padding0;
  uint padding1;
  uint padding2;
};
*/

struct DrawIndexedIndirectCommand {
  uvec4 cmd0; // indexCount_instanceCount_firstIndex_vertexOffset; // x = indexCount, y = instanceCount, z = firstIndex, w = vertexOffset  
  uvec4 cmd1; // firstInstance_padding0_padding1_padding2; // x = firstInstance, yzw = padding for 16 bytes alignment to the next vec4 field
  vec4 boundingSphere; // xyz = center, w = radius
  uvec4 padding3; // just padding 
}; // 64 bytes per draw indexed indirect command, dividable by 32 bytes for better GPU cache line alignment 

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

layout(set = 0, binding = 1, std430) readonly buffer InputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} inputDrawIndexedIndirectCommands;

layout(set = 0, binding = 2, std430) buffer OutputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} outputDrawIndexedIndirectCommands;

layout(set = 0, binding = 3, std430) buffer OutputDrawIndexedIndirectCommandCounts {
  uint counts[];
} outputDrawIndexedIndirectCommandCounts;

layout(set = 0, binding = 4) uniform sampler2DArray uTextureDepth;

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb){

	if (C.z < (r + znear)){
		return false;
  }

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - (r * r)), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - (r * r)), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4((minx.x / minx.y) * P00, (miny.x / miny.y) * P11, (maxx.x / maxx.y) * P00, (maxy.x / maxy.y) * P11);
	aabb = fma(aabb.xwzy, vec4(0.5), vec4(0.5)); // clip space -> uv space

	return true;
}

shared mat4 viewMatrices[8];
shared vec4 inverseProjectionMatrixZData[8];
shared float zNears[8]; 
shared vec2 p00p11[8];
shared vec4 frustums[8];

void main(){

  uint invocationIndex = gl_LocalInvocationID.x;

  // Maximal 8 views at once, for example 2 for VR (for the left und right eyes), 4 for cascaded shadow maps, 6 for cube maps
  uint countViews = min(pushConstants.countViews, 8); 

  if(invocationIndex < countViews){
    
    uint viewIndex = pushConstants.baseViewIndex + invocationIndex;

    viewMatrices[invocationIndex] = uView.views[viewIndex].viewMatrix;

    mat4 projectionMatrix = uView.views[viewIndex].projectionMatrix;

    inverseProjectionMatrixZData[invocationIndex] = vec4(uView.views[viewIndex].inverseProjectionMatrix[2].zw, uView.views[viewIndex].inverseProjectionMatrix[3].zw);

    // Get z near from projection matrix 
    zNears[invocationIndex] = abs(uView.views[viewIndex].inverseProjectionMatrix[3][2] / uView.views[viewIndex].inverseProjectionMatrix[2][3]);

    p00p11[invocationIndex] = vec2(projectionMatrix[0][0], projectionMatrix[1][1]);

    mat4 transposedProjectionMatrix = transpose(uView.views[viewIndex].projectionMatrix);

    frustums[invocationIndex] = vec4(
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[0]).xz, 
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[1]).yz
    );

  }

  memoryBarrierShared();
  groupMemoryBarrier();
  barrier(); 

  if (invocationIndex >= pushConstants.countDrawIndexedIndirectCommands) {
    return;  
  }

  uint sourceIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + invocationIndex;

  vec4 boundingSphere = inputDrawIndexedIndirectCommands.commands[sourceIndex].boundingSphere;

  // Only cull when sphere has a positive radius, since some render passes may not need culling, so we just forward the drawIndexedIndirectCommands 
  // directly to the output buffer in that case.
  if(boundingSphere.w > 0.0){
 
    vec2 viewPortSize = vec2(textureSize(uTextureDepth, 0).xy);

    uint isDrawIndexedIndirectCommandVisibleBits = 0u;

    for(uint viewIndex = 0u, bit = 1u; viewIndex < countViews; viewIndex++, bit <<= 1u){

      vec4 viewSpaceBoundingSphere = vec4((viewMatrices[viewIndex] * vec4(boundingSphere.xyz, 1.0)).xyz, boundingSphere.w);

      vec4 frustum = frustums[viewIndex];

      // Frustum visible check, but without testing the near und far planes, so it is more projection matrix variant independent (reverse z, 
      // infinite far plane, and the like). The CPU culling should already have frustum-culled it away anyway, so this is just a safety check.
      bool visible = (((viewSpaceBoundingSphere.z * frustum.y) - (abs(viewSpaceBoundingSphere.x) - frustum.x)) > -viewSpaceBoundingSphere.w) &&
                     (((viewSpaceBoundingSphere.z * frustum.w) - (abs(viewSpaceBoundingSphere.y) - frustum.z)) > -viewSpaceBoundingSphere.w);

      if(visible){

        vec4 aabb;

        if(projectSphere(viewSpaceBoundingSphere.xyz, viewSpaceBoundingSphere.w, zNears[invocationIndex], p00p11[invocationIndex].x, p00p11[invocationIndex].y, aabb)){

          vec2 size = vec2(aabb.zw - aabb.xy) * viewPortSize;
          float level = floor(log2(max(size.x, size.y))); 

          vec2 depthZ = fma(
            inverseProjectionMatrixZData[invocationIndex].xy, 
            textureLod(uTextureDepth, vec3((aabb.xy + aabb.zw) * 0.5, float(viewIndex)), level).xx, 
            inverseProjectionMatrixZData[invocationIndex].zw
          );
          visible = (viewSpaceBoundingSphere.z - viewSpaceBoundingSphere.w) >= (depthZ.x / depthZ.y);

        }

      }

      isDrawIndexedIndirectCommandVisibleBits |= visible ? bit : 0u;

    }

    if(isDrawIndexedIndirectCommandVisibleBits == 0u){
      return;
    }

  }

  uint destinationIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + atomicAdd(outputDrawIndexedIndirectCommandCounts.counts[pushConstants.drawCallIndex], 1u);
  
  // Just copy the draw indexed indirect command itself, but not the no more needed bounding sphere and so on, to save memory bandwidth
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd0 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd0;
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd1 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd1;

}
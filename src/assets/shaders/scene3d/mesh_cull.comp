#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

#ifndef PASS
#define PASS 0
#endif

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

/*
struct VkDrawIndexedIndirectCommand {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
  uint padding0;
  uint padding1;
  uint padding2;
};
*/

struct DrawIndexedIndirectCommand {
  uvec4 cmd0; // indexCount_instanceCount_firstIndex_vertexOffset; // x = indexCount, y = instanceCount, z = firstIndex, w = vertexOffset  
  uvec4 cmd1; // firstInstance_padding0_padding1_padding2; // x = firstInstance, y = objectIndex, zw = padding for 16 bytes alignment to the next vec4 field
  vec4 boundingSphere; // xyz = center, w = radius
  uvec4 padding3; // just padding 
}; // 64 bytes per draw indexed indirect command, dividable by 32 bytes for better GPU cache line alignment 

#if PASS == 0

layout(push_constant) uniform PushConstants {
  uint baseDrawIndexedIndirectCommandIndex;
  uint countDrawIndexedIndirectCommands;
  uint drawCallIndex;
  uint countObjectIndices;
  uint skipCulling; // 1u if it is the first frame, if there are sudden complete new views, or if the objectIndices are not valid anymore, 0u otherwise
} pushConstants;

layout(set = 0, binding = 0, std430) readonly buffer InputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} inputDrawIndexedIndirectCommands;

layout(set = 0, binding = 1, std430) readonly buffer InputPreviousVisibleObjects {
  uint bitmap[];
} inputPreviousVisibleObjects;

layout(set = 0, binding = 2, std430) buffer OutputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} outputDrawIndexedIndirectCommands;

layout(set = 0, binding = 3, std430) buffer OutputDrawIndexedIndirectCommandCounts {
  uint counts[];
} outputDrawIndexedIndirectCommandCounts;

#else // PASS == 1

layout(push_constant) uniform PushConstants {
  uint baseDrawIndexedIndirectCommandIndex;
  uint countDrawIndexedIndirectCommands;
  uint drawCallIndex;
  uint countObjectIndices;
  uint skipCulling; // 1u if it is the first frame, if there are sudden complete new views, or if the objectIndices are not valid anymore, 0u otherwise
  uint baseViewIndex;
  uint countViews;
} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256
} uView;

layout(set = 0, binding = 1, std430) readonly buffer InputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} inputDrawIndexedIndirectCommands;

layout(set = 0, binding = 2, std430) buffer OutputDrawIndexedIndirectCommands {
  DrawIndexedIndirectCommand commands[];
} outputDrawIndexedIndirectCommands;

layout(set = 0, binding = 3, std430) buffer OutputDrawIndexedIndirectCommandCounts {
  uint counts[];
} outputDrawIndexedIndirectCommandCounts;

layout(set = 0, binding = 4, std430) buffer OutputNewVisibleObjects {
  uint bitmap[];
} outputNewVisibleObjects;

layout(set = 0, binding = 5) uniform sampler2DArray uTextureDepth;

bool referenceProjectSphere(const in vec3 center, const in float radius, const in float zNear, const in mat4 projectionMatrix, out vec4 aabb){

  if(center.z < (radius + zNear)){ //if((-(center.z + radius)) < zNear){

    return false;

  }else{

    vec3 right = (projectionMatrix * vec4(vec3(-center.z, 0.0, center.x) * (radius / sqrt(dot(center, center) - (radius * radius))), 0.0)).xyw;
    vec3 up = (projectionMatrix * vec2(0.0, radius).xyxx).xyw;

    vec3 anchorCenter = (projectionMatrix * vec4(center, 1.0)).xyw;

    vec2 leftAnchor = (anchorCenter.xy - right.xy) / (anchorCenter.z - right.z);
    vec2 rightAnchor = (anchorCenter.xy + right.xy) / (anchorCenter.z + right.z);
    vec2 downAnchor = (anchorCenter.xy - up.xy) / (anchorCenter.z - up.z);
    vec2 upAnchor = (anchorCenter.xy + up.xy) / (anchorCenter.z + up.z);
    
    aabb = fma(
      vec4(
        min(min(min(leftAnchor, rightAnchor), downAnchor), upAnchor), 
        max(max(max(leftAnchor, rightAnchor), downAnchor), upAnchor)
      ), 
      vec4(0.5), 
      vec4(0.5)
    );

    return true;

  }

}

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool projectSphere(vec3 center, float radius, float zNear, float P00, float P11, out vec4 aabb){

  if(center.z < (radius + zNear)){

    return false;

  }else{

    vec2 cx = -center.xz;
    vec2 vx = vec2(sqrt(dot(cx, cx) - (radius * radius)), radius);
    vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
    vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

    vec2 cy = -center.yz;
    vec2 vy = vec2(sqrt(dot(cy, cy) - (radius * radius)), radius);
    vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
    vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

    aabb = fma(
      vec4(
        (minx.x / minx.y) * P00, 
        (miny.x / miny.y) * P11,
        (maxx.x / maxx.y) * P00, 
        (maxy.x / maxy.y) * P11
      ).xwzy, 
      vec4(0.5), 
      vec4(0.5)
    ); 

    return true;

  }  

}

bool coneCull(vec3 center, float radius, vec3 cone_axis, float cone_cutoff, vec3 camera_position){
	return dot(center - camera_position, cone_axis) >= fma(cone_cutoff, length(center - camera_position), radius);
}

float linearizeDepth(const in mat4 inverseProjectionMatrix, const in float z) {
#if 0
  vec2 v = (inverseProjectionMatrix * vec4(vec3(fma(inTexCoord, vec2(2.0), vec2(-1.0)), z), 1.0)).zw;
#else
  vec2 v = fma(inverseProjectionMatrix[2].zw, vec2(z), inverseProjectionMatrix[3].zw);
#endif
  return -(v.x / v.y);
}

shared mat4 viewMatrices[8];
shared mat4 projectionMatrices[8];
shared vec4 inverseProjectionMatrixZData[8];
shared float zNears[8]; 
shared vec2 p00p11[8];
shared vec4 frustums[8];
#endif

void main(){

#if PASS == 0

  // In the first pass, just draw the previous frame visible stuff as against-cull-data (HiZ depth buffer) for the next pass
  // The previous drawIndexedIndirectCommands can't be reused directly here in this everything-in-a-single-round-trip
  // implementation, since as there is the possibility of no more existing objects, different data offsets and so on. Therefore 
  // this first pass is needed, otherwise it would be possible that it breaks, On the other hand, the object indices are temporally 
  // stable, so they can be reused from the previous frame for the starting point HiZ depth buffer.

  uint invocationIndex = gl_LocalInvocationID.x;

  if(invocationIndex >= pushConstants.countDrawIndexedIndirectCommands){
    return;  
  }

  uint sourceIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + invocationIndex;

  const uvec4 cmd0 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd0;
  const uvec4 cmd1 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd1;

  const uint objectIndex = cmd1.y;

  if((pushConstants.skipCulling == 0u) &&  // If it is the first frame or the like, just don't cull anything
     ((objectIndex < pushConstants.countObjectIndices) && // Check if the object index is in the valid range, since
                                                          // new drawIndexedIndirectCommands may have been added 
                                                          // with a higher object index than the current 
                                                          // countObjectIndices in contrast to the previous frame
      ((inputPreviousVisibleObjects.bitmap[objectIndex >> 5u] & (1u << (objectIndex & 31u))) == 0u))){
    return; // Skip, since it was not visible in the previous frame
  }

  uint destinationIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + atomicAdd(outputDrawIndexedIndirectCommandCounts.counts[pushConstants.drawCallIndex], 1u);
  
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd0 = cmd0;
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd1 = cmd1;
  
#else // PASS == 1

  // In the second pass, cull the stuff against the previous frame visible stuff but with the current view and projection matrices

  uint invocationIndex = gl_LocalInvocationID.x;

  // Maximal 8 views at once, for example 2 for VR (for the left und right eyes), 4 for cascaded shadow maps, 6 for cube maps
  uint countViews = min(pushConstants.countViews, 8); 

  if(invocationIndex < countViews){
    
    uint viewIndex = pushConstants.baseViewIndex + invocationIndex;

    viewMatrices[invocationIndex] = uView.views[viewIndex].viewMatrix;

    mat4 projectionMatrix = projectionMatrices[invocationIndex] = uView.views[viewIndex].projectionMatrix;

    inverseProjectionMatrixZData[invocationIndex] = vec4(uView.views[viewIndex].inverseProjectionMatrix[2].zw, uView.views[viewIndex].inverseProjectionMatrix[3].zw);

    // Get z near from projection matrix 
    zNears[invocationIndex] = abs(uView.views[viewIndex].inverseProjectionMatrix[3][2] / uView.views[viewIndex].inverseProjectionMatrix[2][3]);

    p00p11[invocationIndex] = vec2(projectionMatrix[0][0], projectionMatrix[1][1]);

    mat4 transposedProjectionMatrix = transpose(uView.views[viewIndex].projectionMatrix);

    frustums[invocationIndex] = vec4(
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[0]).xz, 
      normalize(transposedProjectionMatrix[3] + transposedProjectionMatrix[1]).yz
    );

  }

  memoryBarrierShared();
  groupMemoryBarrier();
  barrier(); 

  if(invocationIndex >= pushConstants.countDrawIndexedIndirectCommands){
    return;  
  }

  uint sourceIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + invocationIndex;

  vec4 boundingSphere = inputDrawIndexedIndirectCommands.commands[sourceIndex].boundingSphere;

  bool isDrawIndexedIndirectCommandVisible = false;

  const uvec4 cmd0 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd0;

  // Only cull when needed, since some render passes may not need culling, so we just forward the drawIndexedIndirectCommands 
  // directly to the output buffer in that case. And don't cull draw items with more than one instance, since in this case
  // the bounding sphere is not valid for all instances.
  if((boundingSphere.w > 0.0) && (pushConstants.skipCulling == 0u) && (cmd0.y == 1u)){
 
    vec2 viewPortSize = vec2(textureSize(uTextureDepth, 0).xy);

    uint isDrawIndexedIndirectCommandVisibleBits = 0u;

    for(uint viewIndex = 0u, bit = 1u; viewIndex < countViews; viewIndex++, bit <<= 1u){

      vec4 viewSpaceBoundingSphere = vec4((viewMatrices[viewIndex] * vec4(boundingSphere.xyz, 1.0)).xyz, boundingSphere.w);

      vec4 frustum = frustums[viewIndex];

      // Frustum visible check, but without testing the near und far planes, so it is more projection matrix variant independent (reverse z, 
      // infinite far plane, and the like). The CPU culling should already have frustum-culled it away anyway, so this is just a safety check.
      bool visible = true; /* (((viewSpaceBoundingSphere.z * frustum.y) - (abs(viewSpaceBoundingSphere.x) - frustum.x)) > -viewSpaceBoundingSphere.w) &&
                     (((viewSpaceBoundingSphere.z * frustum.w) - (abs(viewSpaceBoundingSphere.y) - frustum.z)) > -viewSpaceBoundingSphere.w);*/

      if(visible){

        vec4 aabb;

        if(
#if 0
          referenceProjectSphere(viewSpaceBoundingSphere.xyz, viewSpaceBoundingSphere.w, zNears[viewIndex], projectionMatrices[viewIndex], aabb)
#else
          projectSphere(viewSpaceBoundingSphere.xyz, viewSpaceBoundingSphere.w, zNears[viewIndex], p00p11[viewIndex].x, p00p11[viewIndex].y, aabb)
#endif          
        ){

          vec2 size = vec2(aabb.zw - aabb.xy) * viewPortSize;
          float level = floor(log2(max(size.x, size.y))); 

          vec2 depthZ = fma(
            inverseProjectionMatrixZData[invocationIndex].xy, 
            textureLod(uTextureDepth, vec3((aabb.xy + aabb.zw) * 0.5, float(viewIndex)), level).xx, 
            inverseProjectionMatrixZData[invocationIndex].zw
          );
          visible = (viewSpaceBoundingSphere.z - viewSpaceBoundingSphere.w) >= (depthZ.x / depthZ.y);

        }

      }

      isDrawIndexedIndirectCommandVisibleBits |= visible ? bit : 0u;

    }

    isDrawIndexedIndirectCommandVisible = isDrawIndexedIndirectCommandVisibleBits != 0u;

  }else{
      
    isDrawIndexedIndirectCommandVisible = true;

  }

  const uvec4 cmd1 = inputDrawIndexedIndirectCommands.commands[sourceIndex].cmd1;

  const uint objectIndex = cmd1.y;
  
  if(!isDrawIndexedIndirectCommandVisible){
    return;
  }

  atomicOr(outputNewVisibleObjects.bitmap[objectIndex >> 5u], 1u << (objectIndex & 31u));

  uint destinationIndex = pushConstants.baseDrawIndexedIndirectCommandIndex + atomicAdd(outputDrawIndexedIndirectCommandCounts.counts[pushConstants.drawCallIndex], 1u);
  
  // Just copy the draw indexed indirect command itself, but not the no more needed bounding sphere and so on, to save memory bandwidth
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd0 = cmd0;
  outputDrawIndexedIndirectCommands.commands[destinationIndex].cmd1 = cmd1;

#endif

}
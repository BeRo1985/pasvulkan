#version 450 core
/*
 * cnn_buffer_to_image.comp — Convert flat SSBO (sRGB [0,1]) → output image (linear HDR)
 *
 * Post-processing step for CNN upscaler inference.
 * Reads from a flat float SSBO in NCHW layout (3 channels, planar),
 * applies sRGB→linear conversion + inverse tone mapping, and writes
 * to a storage image (the full-resolution color target).
 *
 * Bindings:
 *   0 = input SSBO (readonly, float[batch * 3 * oH * oW])
 *   1 = output image (storage image, rgba16f)
 *
 * Push constants:
 *   outputHeight, outputWidth
 *
 * Dispatch: ((oW+15)/16, (oH+15)/16, viewCount)
 *
 * Copyright (C) 2026 Benjamin 'BeRo' Rosseaux. License see PasVulkan.Framework.pas (zlib)
 */

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  int outputHeight;
  int outputWidth;
  int padding0;
  int padding1;
  int padding2;
  int padding3;
  int padding4;
  int padding5;
} pushConstants;

layout(set = 0, binding = 0) readonly buffer InputBuffer { float inputData[]; };
layout(set = 0, binding = 1, rgba16f) writeonly uniform image2DArray uOutputImage;

#include "bidirectional_tonemapping.glsl"
#include "srgb.glsl"

void main() {
  int x = int(gl_GlobalInvocationID.x);
  int y = int(gl_GlobalInvocationID.y);
  int viewIndex = int(gl_GlobalInvocationID.z);

  int outputHeight = pushConstants.outputHeight;
  int outputWidth = pushConstants.outputWidth;

  if (x >= outputWidth || y >= outputHeight) {
    return;
  }

  // Read planar NCHW from CNN output
  int channelStride = outputHeight * outputWidth;
  int baseOffset = viewIndex * 3 * channelStride;
  int pixelOffset = (y * outputWidth) + x;
  vec3 srgbColor = vec3(
    inputData[baseOffset + (0 * channelStride) + pixelOffset],
    inputData[baseOffset + (1 * channelStride) + pixelOffset],
    inputData[baseOffset + (2 * channelStride) + pixelOffset]
  );

  // Clamp to valid range
  srgbColor = clamp(srgbColor, vec3(0.0), vec3(1.0));

  // sRGB → linear (inverse of pre-processing)
  vec3 linearColor = convertSRGBToLinearRGB(srgbColor);

  // Apply inverse tone mapping (decompress back to HDR range)
  linearColor = ApplyInverseToneMapping(linearColor);

  imageStore(uOutputImage, ivec3(x, y, viewIndex), vec4(linearColor, 1.0));
}

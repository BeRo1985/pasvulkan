#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(push_constant, std140, row_major) uniform PushConstants {
  uvec4 tileSizeZNearZFar; 
  vec4 viewRect;
  uvec4 countLightsViewIndexSize;
} pushConstants;

layout(std140, set = 0, binding = 0) buffer InverseProjectionMatrices {
  mat4 inverseProjectionMatrices[];
};

struct AABB {
  vec4 minBounds;
  vec4 maxBounds; 
};

layout(std430, set = 0, binding = 1) buffer LightGridClusterAABBs {
  AABB lightGridClusterAABBs[];
};

layout (std430, set = 0, binding = 2) buffer LightGridIndexListCounter {
  uint lightGridIndexListCounter;
};
/* clang-format on */

vec4 screen2Eye(vec4 coord) {
  vec2 ndc = fma((coord.xy - pushConstants.viewRect.xy) / pushConstants.viewRect.zw, vec2(2.0), vec2(-1.0));
  vec4 eye = inverseProjectionMatrices[pushConstants.countLightsViewIndexSize.y] * vec4(ndc, coord.z, 1.0);
  return eye / eye.w;
}

void main() {
  //
  const float infinity = uintBitsToFloat(0x7f800000u);

  uvec3 globalInvocationID = uvec3(gl_GlobalInvocationID.xyz); //(gl_WorkGroupID.xyz * gl_WorkGroupSize.xyz) + gl_LocalInvocationID.xyz; 
  uvec3 globalSize = uvec3(gl_NumWorkGroups.xyz * gl_WorkGroupSize.xyz); 
  uint globalInvocationIndex = (((globalInvocationID.z * globalSize.y) + globalInvocationID.y) * globalSize.x) + globalInvocationID.x;
 
  uint clusterIndex = globalInvocationIndex + (pushConstants.countLightsViewIndexSize.y * pushConstants.countLightsViewIndexSize.z);

#ifdef REVERSEDZ
  vec4 minScreen = vec4(vec2(uvec2(globalInvocationID.xy) * pushConstants.tileSizeZNearZFar.xy), 1.0, 1.0);
  vec4 maxScreen = vec4(vec2((uvec2(globalInvocationID.xy) + uvec2(1)) * pushConstants.tileSizeZNearZFar.xy), 1.0, 1.0);
#else
  vec4 minScreen = vec4(vec2(uvec2(globalInvocationID.xy) * pushConstants.tileSizeZNearZFar.xy), 0.0, 1.0);
  vec4 maxScreen = vec4(vec2((uvec2(globalInvocationID.xy) + uvec2(1)) * pushConstants.tileSizeZNearZFar.xy), 0.0, 1.0);
#endif

  vec3 minEye = screen2Eye(minScreen).xyz;
  vec3 maxEye = screen2Eye(maxScreen).xyz;

  vec2 ZNearZFar = uintBitsToFloat(pushConstants.tileSizeZNearZFar.zw);

  float clusterNear = ZNearZFar.x * pow(ZNearZFar.y / ZNearZFar.x, globalInvocationID.z / float(globalSize.z));
  float clusterFar = ((globalInvocationID.z + 1u) == globalSize.z)  //
                         ? infinity                                 // the last cluster depth row is going into the infinity for a reserved z projection matrix with an actually infinite z far plane
                         : (ZNearZFar.x * pow(ZNearZFar.y / ZNearZFar.x, (globalInvocationID.z + 1) / float(globalSize.z)));

  vec3 minNear = (minEye * clusterNear) / minEye.z;
  vec3 minFar = (minEye * clusterFar) / minEye.z;
  vec3 maxNear = (maxEye * clusterNear) / maxEye.z;
  vec3 maxFar = (maxEye * clusterFar) / maxEye.z;

  lightGridClusterAABBs[clusterIndex].minBounds = vec4(vec3(min(min(minNear, minFar), min(maxNear, maxFar))), 1.0);
  lightGridClusterAABBs[clusterIndex].maxBounds = vec4(vec3(max(max(minNear, minFar), max(maxNear, maxFar))), 1.0);

  if(clusterIndex == 0u){
    lightGridIndexListCounter = 0u; 
  }

}

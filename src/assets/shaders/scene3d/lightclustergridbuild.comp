#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(push_constant, std140, row_major) uniform PushConstants {
  ivec2 tileSize; 
  vec2 zNearFar;
  vec4 viewRect;
  int countLights;
  int viewIndex;
} pushConstants;

layout(std430, set = 0, binding = 0) buffer InverseProjectionMatrices {
  mat4 inverseProjectionMatrices[];
};

struct AABB {
  vec4 minBounds;
  vec4 maxBounds; 
};

layout(std430, set = 0, binding = 1) buffer Clusters {
  AABB clusterAABBs[];
};

/* clang-format on */

vec4 screen2Eye(vec4 coord) {
  vec3 ndc = fma(vec3((coord.xy - pushConstants.viewRect.xy) / pushConstants.viewRect.zw, coord.z), vec3(2.0), vec3(-1.0));
  vec4 eye = inverseProjectionMatrices[pushConstants.viewIndex] * vec4(ndc, 1.0);
  return eye / eye.w;
}

void main() {
  //
  const float infinity = uintBitsToFloat(0x7f800000u);

  ivec3 globalInvocationID = ivec3(gl_GlobalInvocationID.xyz); //(gl_WorkGroupID.xyz * gl_WorkGroupSize.xyz) + gl_LocalInvocationID.xyz; 
  ivec3 globalSize = ivec3(gl_NumWorkGroups.xyz * gl_WorkGroupSize.xyz); 
  int globalInvocationIndex = (((globalInvocationID.z * globalSize.y) + globalInvocationID.y) * globalSize.x) + globalInvocationID.x;
 
  int clusterIndex = globalInvocationIndex + (pushConstants.viewIndex * (16 * 8 * 32));

#ifdef REVERSEDZ
  vec4 minScreen = vec4(vec2(ivec2(globalInvocationID.xy) * pushConstants.tileSize.xy), 1.0, 1.0);
  vec4 maxScreen = vec4(vec2((ivec2(globalInvocationID.xy) + ivec2(1)) * pushConstants.tileSize.xy), 1.0, 1.0);
#else
  vec4 minScreen = vec4(vec2(ivec2(globalInvocationID.xy) * pushConstants.tileSize.xy), 0.0, 1.0);
  vec4 maxScreen = vec4(vec2((ivec2(globalInvocationID.xy) + ivec2(1)) * pushConstants.tileSize.xy), 0.0, 1.0);
#endif

  vec3 minEye = screen2Eye(minScreen).xyz;
  vec3 maxEye = screen2Eye(maxScreen).xyz;

  float clusterNear = pushConstants.zNearFar.x * pow(pushConstants.zNearFar.y / pushConstants.zNearFar.x, globalInvocationID.z / float(globalSize.z));
  float clusterFar = ((globalInvocationID.z + 1) == globalSize.z)  //
                         ? infinity                                // the last cluster depth row is going into the infinity for a reserved z projection matrix with an actually infinite z far plane
                         : (pushConstants.zNearFar.x * pow(pushConstants.zNearFar.y / pushConstants.zNearFar.x, (globalInvocationID.z + 1) / float(globalSize.z)));

  vec3 minNear = (minEye * clusterNear) / minEye.z;
  vec3 minFar = (minEye * clusterFar) / minEye.z;
  vec3 maxNear = (maxEye * clusterNear) / maxEye.z;
  vec3 maxFar = (maxEye * clusterFar) / maxEye.z;

  clusterAABBs[clusterIndex].minBounds = vec4(vec3(min(min(minNear, minFar), min(maxNear, maxFar))), 1.0);
  clusterAABBs[clusterIndex].maxBounds = vec4(vec3(max(max(minNear, minFar), max(maxNear, maxFar))), 1.0);
}

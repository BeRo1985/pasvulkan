#version 450 core

#pragma shader_stage(compute)

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive : enable

/* clang-format off */

layout(local_size_x = 1, local_size_y = 8, local_size_z = 8) in;

layout(push_constant) uniform PushConstants {
  mat4 modelMatrix;

  uint baseViewIndex;
  uint countViews;
  uint additionalViewIndex;
  uint countAdditionalViews; 

  uint tileMapResolution;
  uint tileResolution;  
  float bottomRadius;
  float topRadius;

  uint maximumCountVertices;
  uint maximumCountIndices;
  float grassHeight;
  float grassThickness;

} pushConstants;

struct View {
  mat4 viewMatrix;
  mat4 projectionMatrix;
  mat4 inverseViewMatrix;
  mat4 inverseProjectionMatrix;
};

layout(set = 0, binding = 0, std140) uniform uboViews {
  View views[256]; // 65536 / (64 * 4) = 256 views as maximum for a single renderer instance (but a application/game can have multiple renderer instances for the same scene)  
} uView;

layout(set = 0, binding = 1) uniform sampler2DArray uTextureDepth;

layout(set = 0, binding = 2, std430) buffer VisibleTileList {
  uint visibleTiles[];
} visibleTileList;

layout(set = 0, binding = 2, std430) buffer VisualMeshVertices {
  uvec4 vertices[]; // xyz = 32-bit float vertex position, w = 2x 16-bit signed normalized octahedral-encoded normal
} visualMeshVertices;

#include "frustum.glsl"

#include "aabb.glsl"
  
#include "projectsphere.glsl"

#include "projectaabb.glsl"

#include "octahedral.glsl"

#include "tangentspacebasis.glsl"

// The following variables are shared between all invocations of this shader for too keep the pre-calculations needed for the culling small, which
// are valid and the same for all invocations anyway. Other implementations uses CPU pre-calculations for it, but this is a more simple and straight 
// forward approach in my opinion, so that almost everything is done on the GPU and is in the same place, as long as it don't hurts the performance
// significantly.
shared vec3 planetPosition;
shared Frustum frustums[8];
shared Frustum additionalFrustums[8];

void main(){

  const uint countLODLevels = uint(log2(float(pushConstants.tileResolution)));

  uint localInvocationIndex = gl_LocalInvocationID.x;

  // Maximal 8 views at once, for example 2 for VR (for the left und right eyes), 4 for cascaded shadow maps, 6 for cube maps
  uint countViews = min(pushConstants.countViews, 8); 

  if(localInvocationIndex == 0u){
    vec4 p = pushConstants.modelMatrix * vec4(0.0, 0.0, 0.0, 1.0);
    planetPosition = p.xyz / p.w;
  }

  if((countViews > 0u) && (localInvocationIndex < countViews)){   
    frustumSetup(frustums[localInvocationIndex], uView.views[pushConstants.baseViewIndex + localInvocationIndex].projectionMatrix);      
  }

  if((pushConstants.countAdditionalViews > 0u) && (localInvocationIndex < pushConstants.countAdditionalViews)){   
    frustumSetup(additionalFrustums[localInvocationIndex], uView.views[pushConstants.additionalViewIndex + localInvocationIndex].projectionMatrix);      
  }

  memoryBarrierShared();
  groupMemoryBarrier();
  barrier(); 

  const uint tileListIndex = gl_GlobalInvocationID.x;  

  const uint tileMapSize = pushConstants.tileMapResolution * pushConstants.tileMapResolution;

  const uint countVisibleTiles = visibleTileList.visibleTiles[0];

  const uvec2 localTileXY = uvec2(gl_GlobalInvocationID.yz);

  if((tileListIndex < tileMapSize) && 
     (tileListIndex < countVisibleTiles) && 
     all(lessThanEqual(localTileXY, uvec2(pushConstants.tileResolution)))){ 

    vec2 viewPortSize = vec2(textureSize(uTextureDepth, 0).xy);
    int countLODLevels = textureQueryLevels(uTextureDepth);

    const uint tileMapIndex = visibleTileList.visibleTiles[tileListIndex + 1u];

    const uint tileMapY = tileMapIndex / pushConstants.tileMapResolution;
    const uint tileMapX = tileMapIndex - (tileMapY * pushConstants.tileMapResolution);

    uvec2 globalXY = (uvec2(tileMapX, tileMapY) * pushConstants.tileResolution) + uvec2(gl_GlobalInvocationID.yz);

    uint globalIndex = (globalXY.y * (pushConstants.tileMapResolution * pushConstants.tileResolution)) + globalXY.x;

    /////////////////////////////////////////////////////////////////////////

    uvec4 rawVertex = visualMeshVertices.vertices[globalIndex];

    vec3 vertexPosition = uintBitsToFloat(rawVertex.xyz);

    vec3 vertexNormal = octSignedDecode(unpackSnorm2x16(rawVertex.w));      

    vec3 vertexTangent, vertexBitangent;

    getTangentSpaceBasisFromNormal(vertexNormal, vertexTangent, vertexBitangent); 

    /////////////////////////////////////////////////////////////////////////

    vec3 worstCaseBaseVertexPosition = vertexPosition;
    vec3 worstCaseTipVertexPosition = vertexPosition + (vertexNormal * pushConstants.grassHeight); 

    vec3 tangentThickness = vertexTangent * pushConstants.grassThickness;
    vec3 bitangentThickness = vertexBitangent * pushConstants.grassThickness;

    /////////////////////////////////////////////////////////////////////////

    vec3 aabbEdges[8] = vec3[8](
      (worstCaseBaseVertexPosition - tangentThickness) - bitangentThickness,
      (worstCaseBaseVertexPosition + tangentThickness) - bitangentThickness,
      (worstCaseBaseVertexPosition + tangentThickness) + bitangentThickness,
      (worstCaseBaseVertexPosition - tangentThickness) + bitangentThickness,
      (worstCaseTipVertexPosition - tangentThickness) - bitangentThickness,
      (worstCaseTipVertexPosition + tangentThickness) - bitangentThickness,
      (worstCaseTipVertexPosition + tangentThickness) + bitangentThickness,
      (worstCaseTipVertexPosition - tangentThickness) + bitangentThickness
    );

    vec3 aabbMin = min(min(min(aabbEdges[0], aabbEdges[1]), min(aabbEdges[2], aabbEdges[3])), min(min(aabbEdges[4], aabbEdges[5]), min(aabbEdges[6], aabbEdges[7])));
    vec3 aabbMax = max(max(max(aabbEdges[0], aabbEdges[1]), max(aabbEdges[2], aabbEdges[3])), max(max(aabbEdges[4], aabbEdges[5]), max(aabbEdges[6], aabbEdges[7]))); 

    /////////////////////////////////////////////////////////////////////////

    vec4 boundingSphere = vec4(mix(aabbMin, aabbMax, 0.5), length(aabbMax - aabbMin) * 0.5);

    /////////////////////////////////////////////////////////////////////////
    
    bool visible = false;
    
    for(uint viewIndex = 0u; viewIndex < countViews; viewIndex++){
      
      mat4 viewMatrix = uView.views[pushConstants.baseViewIndex + viewIndex].viewMatrix;      
      vec4 viewSpaceBoundingSphere = vec4((viewMatrix * vec4(boundingSphere.xyz, 1.0)).xyz, boundingSphere.w);

      if(frustumCullingSphereTest(frustums[viewIndex], viewSpaceBoundingSphere)){
      
        vec3 viewSpaceAABBMin = aabbMin;
        vec3 viewSpaceAABBMax = aabbMax;
      
        mat4 modelViewMatrix = viewMatrix * pushConstants.modelMatrix;
      
        aabbTransform(viewSpaceAABBMin, viewSpaceAABBMax, modelViewMatrix);
      
        if(frustumCullingAABBTest(frustums[viewIndex], viewSpaceAABBMin, viewSpaceAABBMax)){
          
          visible = true;

          vec4 aabb;

          float zNear = abs(uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix[3][2] / uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix[2][3]);

//        if(projectAABB(viewSpaceAABBMin, viewSpaceAABBMax, zNear, uView.views[pushConstants.baseViewIndex + viewIndex].projectionMatrix, aabb, true)){
          if(projectSphere(viewSpaceBoundingSphere.xyz, viewSpaceBoundingSphere.w, zNear, uView.views[pushConstants.baseViewIndex + viewIndex].projectionMatrix, aabb, true)){

            vec2 size = vec2(aabb.zw - aabb.xy) * viewPortSize;
            
            float level = clamp(floor(log2(max(size.x, size.y))), 0.0, float(countLODLevels - 1)); 

  #undef USE_FASTER_DEPTH_CALCULATIONS
  #ifdef USE_FASTER_DEPTH_CALCULATIONS
            vec2 depthZ = fma(
              uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix[2].zw,
              textureLod(uTextureDepth, vec3(mix(aabb.xy, aabb.zw, 0.5), float(viewIndex)), level).xx, 
              uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix[3].zw
            );
  #else
            vec2 depthZ = (uView.views[pushConstants.baseViewIndex + viewIndex].inverseProjectionMatrix * vec4(
              (aabb.xy + aabb.zw) - vec2(1.0), // optimized from: fma(mix(aabb.xy, aabb.zw, 0.5), vec2(2.0), vec2(-1.0))
              textureLod(uTextureDepth, vec3(mix(aabb.xy, aabb.zw, 0.5), float(viewIndex)), level).x, 
              1.0
            )).zw;
  #endif
            float depth = -(depthZ.x / depthZ.y); // flip the sign, because z in view space is negative otherwise
            
            visible = (((-viewSpaceBoundingSphere.z) - viewSpaceBoundingSphere.w) <= depth);

          }

          if(visible){
            break;
          }

        }

      }

      if(visible){
        break;
      }

    }

    /////////////////////////////////////////////////////////////////////////

    if(visible){

      
      

    }

  }
  

}

